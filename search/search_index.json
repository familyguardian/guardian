{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Guardian","text":"<p>WARNING: THIS SOFTWARE IS NOT READY FOR PRODUCTION OR REAL-WORLD USE!</p> <p>Guardian is under active development. It is experimental, incomplete, and may contain serious bugs or security issues. DO NOT use this software to protect children, enforce limits, or for any purpose where safety, privacy, or reliability matter. Use at your own risk. The maintainers do NOT recommend or support real-world deployment at this time.</p> <pre><code>Helping Families Build Healthy Media Habits\n</code></pre>"},{"location":"#what-is-guardian","title":"What is Guardian?","text":"<p>Guardian is a parental control system for Linux that helps families guide their children toward a healthy relationship with media, the internet, and especially video games. Guardian empowers parents to set reasonable boundaries, encourage positive habits, and foster open conversations about digital life.</p>"},{"location":"#why-use-guardian","title":"Why Use Guardian?","text":"<ul> <li>Support healthy routines: Set daily time limits and curfews for computer and gaming use, tailored to each child.</li> <li>Encourage balance: Help children learn to manage their screen time and prioritize school, sleep, and family activities.</li> <li>Cross-device protection: Guardian works across all family computers, laptops, and gaming devices, so limits are   enforced everywhere.</li> <li>Peace of mind: Automated enforcement means parents don\u2019t have to constantly monitor or argue about time spent online.</li> <li>Transparency: Children see friendly reminders and notifications, so expectations are clear and fair.</li> <li>Parent dashboard: Easily review usage, adjust limits, and grant bonus time when needed.</li> </ul>"},{"location":"#how-guardian-works","title":"How Guardian Works","text":"<p>Guardian is made up of several components that work together to provide robust, flexible, and family-friendly control:</p>"},{"location":"#device-service-guardian-daemon","title":"Device Service (guardian-daemon)","text":"<ul> <li>Runs quietly in the background on each device.</li> <li>Tracks logins and actual usage time for each child.</li> <li>Enforces daily quotas and curfews, blocking logins or ending sessions when limits are reached.</li> <li>Works even if the device is offline; syncs with the central server when reconnected.</li> </ul>"},{"location":"#friendly-reminders-guardian-agent","title":"Friendly Reminders (guardian-agent)","text":"<ul> <li>Shows notifications to children as they approach their limits.</li> <li>Encourages self-regulation and positive habits.</li> </ul>"},{"location":"#parent-dashboard-guardian-hub-not-yet-implemented","title":"Parent Dashboard (guardian-hub - not yet implemented)","text":"<ul> <li>Web-based and CLI tools for parents to view activity, adjust rules, and manage devices.</li> <li>See how much time each child has spent, across all devices.</li> <li>Grant bonus time or change limits instantly.</li> </ul>"},{"location":"#central-server-guardian-hub-not-yet-implemented","title":"Central Server (guardian-hub - not yet implemented)","text":"<ul> <li>Keeps track of all devices, users, and policies.</li> <li>Ensures rules are consistent and up-to-date everywhere.</li> <li>Provides secure authentication and audit logs for accountability.</li> </ul>"},{"location":"#example-setting-up-guardian-for-your-family","title":"Example: Setting Up Guardian for Your Family","text":"<ol> <li>Create a Linux account for each child.</li> <li>Install Guardian on all family devices.</li> <li>Set daily time limits and curfew hours for each child in the dashboard.</li> <li>Review usage reports and adjust rules as needed.</li> <li>Talk with your children about healthy media habits and why these boundaries matter.</li> </ol>"},{"location":"#frequently-asked-questions","title":"Frequently Asked Questions","text":"<p>Does Guardian block specific games or websites?</p> <p>Not yet, but app allowlists and blocklists are planned for future releases. For now, Guardian focuses on overall time and healthy routines.</p> <p>Can my child use their computer for homework after their gaming time is up?</p> <p>You can set different rules for weekdays, weekends, and bonus time. Guardian is flexible to fit your family\u2019s needs.</p> <p>What happens if the internet goes down?</p> <p>Guardian enforces rules locally on each device, so limits and curfews still apply even if the server is offline.</p> <p>Is my family\u2019s data safe?</p> <p>Guardian uses secure authentication and stores only what\u2019s needed for enforcement. Parents control all settings and data.</p>"},{"location":"#tips-for-parents","title":"Tips for Parents","text":"<ul> <li>Use Guardian as a tool for conversation, not just enforcement.</li> <li>Involve your children in setting limits and talk about why balance matters.</li> <li>Review usage together and celebrate positive habits.</li> <li>Adjust rules as your children grow and their needs change.</li> </ul>"},{"location":"#learn-more-get-started","title":"Learn More &amp; Get Started","text":"<p>Visit the Guardian website for installation guides, troubleshooting, and community support.</p> <p>For technical details, see the Developer Documentation.</p>"},{"location":"developer/","title":"Guardian Developer Guide","text":"<p>Welcome to the Guardian developer documentation! This guide explains how the project is developed, what is expected from contributors, and how you can get started contributing to Guardian.</p>"},{"location":"developer/#contribution-guidelines","title":"Contribution Guidelines","text":"<ul> <li>Code style: Follow PEP8 and use type hints where possible. All code should be well-documented with clear docstrings   in English.</li> <li>Pre-commit hooks: You must install lefthook to ensure code quality and formatting. See below for setup instructions.</li> <li>Tests: All new features and bugfixes should include relevant tests.</li> <li>Documentation: Update or add documentation for any new modules, features, or CLI commands.</li> <li>Pull requests: Make sure your branch is up to date with <code>main</code> and all checks pass before submitting a PR.</li> </ul>"},{"location":"developer/#project-setup-workflow","title":"Project Setup &amp; Workflow","text":"<p>Guardian uses uv for Python environment and dependency management. Each subproject has its own <code>pyproject.toml</code> and isolated virtualenv.</p>"},{"location":"developer/#basic-uv-commands","title":"Basic uv Commands","text":"<p>Create a virtual environment for a subproject:</p> <pre><code>cd guardian_daemon\nuv venv\n</code></pre> <p>Install dependencies:</p> <pre><code>uv pip install -r requirements.txt\n# or\nuv pip install .\n</code></pre> <p>Upgrade dependencies:</p> <pre><code>uv pip upgrade\n</code></pre> <p>Run scripts:</p> <pre><code>uv run main.py\n</code></pre>"},{"location":"developer/#lefthook-setup","title":"Lefthook Setup","text":"<p>Guardian uses lefthook for git pre-commit hooks (linting, formatting, etc.).</p> <p>Install lefthook hooks for your repo:</p> <pre><code>uv run lefthook install\n</code></pre> <p>This ensures all code is checked before commits and PRs.</p>"},{"location":"developer/#building-documentation-with-mkdocs","title":"Building Documentation with MkDocs","text":"<p>Guardian uses MkDocs for user and developer documentation.</p> <p>To build and serve the docs locally:</p> <pre><code>uv pip install mkdocs\nmkdocs serve\n</code></pre> <p>The documentation will be available at http://localhost:8000</p>"},{"location":"developer/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Fork the repository and clone your fork.</li> <li>Create a new branch for your feature or fix.</li> <li>Set up your environment with uv and lefthook as described above.</li> <li>Make your changes, add tests and documentation.</li> <li>Run all checks and make sure everything passes.</li> <li>Submit a pull request with a clear description of your changes.</li> </ol>"},{"location":"developer/#community-support","title":"Community &amp; Support","text":"<p>If you have questions or want to discuss ideas, open an issue or join our community chat (see the main README for links).</p> <p>Thank you for helping make Guardian better for families everywhere!</p>"},{"location":"developer/code_review_guardian_daemon/","title":"Guardian Daemon Code Review","text":"<p>Date: November 10, 2025 Reviewer: Expert Python Developer Component: guardian_daemon Version: 0.1.0</p>"},{"location":"developer/code_review_guardian_daemon/#executive-summary","title":"Executive Summary","text":"<p>This code review examines the <code>guardian_daemon</code> component, a systemd-based parental control daemon for Linux systems. The daemon monitors user sessions, enforces time quotas and curfews, and manages PAM-based login restrictions.</p> <p>Overall Assessment: The codebase demonstrates solid architectural design with clear separation of concerns. The implementation is largely functional for Phase 0 (local device control). However, there are several areas requiring improvement in error handling, code quality, security, and maintainability.</p> <p>Key Strengths: - Well-structured modular architecture - Comprehensive session tracking with lock/unlock awareness - Good use of SQLAlchemy ORM for database operations - Thoughtful handling of daemon restarts (session restoration) - Extensive logging throughout</p> <p>Critical Issues Found: 7 Critical Issues Fixed: \u2705 7/7 (100%) Major Issues Found: 15 Minor Issues Found: 22 Suggestions: 18</p>"},{"location":"developer/code_review_guardian_daemon/#critical-issues-all-fixed","title":"\u2705 Critical Issues - All Fixed!","text":"<p>All 7 critical security and reliability issues have been addressed:</p> <ol> <li>\u2705 Database Connection Pooling (commit f442d72) - Added StaticPool for thread-safe SQLite access</li> <li>\u2705 D-Bus Connection Robustness (commit e610de7) - Auto-reconnection with exponential backoff</li> <li>\u2705 Race Condition Protection (commit e4e351d) - Verified DB updates inside locks</li> <li>\u2705 Path Traversal Prevention (commit 8485837) - Username validation with strict regex</li> <li>\u2705 PAM Configuration Safety (commit 51ca021) - Timestamped backups, validation, atomic writes</li> <li>\u2705 IPC Socket Security (commit 0d952e8) - Request limits and rate limiting</li> </ol> <p>Note: Issue #7 (Circular Dependencies) requires architectural refactoring and will be addressed separately.</p>"},{"location":"developer/code_review_guardian_daemon/#1-architecture-design","title":"1. Architecture &amp; Design","text":""},{"location":"developer/code_review_guardian_daemon/#11-strengths","title":"1.1 \u2705 Strengths","text":"<p>Modular Design - Clear separation of concerns across modules (policy, storage, sessions, enforcer, etc.) - Each component has a well-defined responsibility - Good abstraction layers between database, policy, and business logic</p> <p>Session Management - Excellent handling of session restoration after daemon restarts - Lock/unlock awareness prevents time accumulation during screen lock - Proper use of asyncio locks to prevent race conditions</p> <p>Configuration System - Two-layer approach (defaults + user overrides) is well thought out - Priority-based config loading is logical and well-documented</p>"},{"location":"developer/code_review_guardian_daemon/#12-areas-for-improvement","title":"1.2 \u26a0\ufe0f Areas for Improvement","text":"<p>CRITICAL: Circular Dependencies <pre><code># In sessions.py\nfrom guardian_daemon.user_manager import UserManager\n\n# In user_manager.py\nif TYPE_CHECKING:\n    from guardian_daemon.sessions import SessionTracker\n</code></pre></p> <p>Issue: The circular dependency between <code>SessionTracker</code> and <code>UserManager</code> is resolved using <code>TYPE_CHECKING</code>, but the runtime dependency still exists through <code>set_tracker()</code>. This is fragile and error-prone.</p> <p>Recommendation: Refactor to use dependency injection or event-based communication. Consider introducing an intermediate coordinator class.</p> <p>MAJOR: Tight Coupling</p> <p>The <code>GuardianDaemon</code> class in <code>__main__.py</code> manually wires all components together. This makes testing difficult and violates dependency inversion principles.</p> <p>Recommendation: Implement a dependency injection container or factory pattern to manage component lifecycle and dependencies.</p>"},{"location":"developer/code_review_guardian_daemon/#2-error-handling-robustness","title":"2. Error Handling &amp; Robustness","text":""},{"location":"developer/code_review_guardian_daemon/#21-critical-issues","title":"2.1 \u274c Critical Issues","text":"<p>CRITICAL: Unhandled D-Bus Disconnections \u2705 FIXED <pre><code># sessions.py - FIXED in commit e610de7\nasync def _get_dbus_connection(self):\n    \"\"\"Get or create a D-Bus connection with retry logic.\"\"\"\n    max_retries = 3\n    retry_delay = 2.0\n    for attempt in range(max_retries):\n        try:\n            bus = await MessageBus(bus_type=BusType.SYSTEM).connect()\n            # ... connection setup with retry logic\n            return bus, manager\n        except Exception as e:\n            if attempt &lt; max_retries - 1:\n                await asyncio.sleep(retry_delay)\n                retry_delay *= 2  # Exponential backoff\n\nasync def periodic_session_update(self, interval: int = 60):\n    bus = None\n    manager = None\n    while True:\n        try:\n            if bus is None or manager is None:\n                bus, manager = await self._get_dbus_connection()\n            # ... with auto-reconnection on errors\n</code></pre></p> <p>Issue: D-Bus connection is established once at the start of the loop. If the system D-Bus daemon restarts or connection drops, the entire daemon could crash or hang.</p> <p>Resolution: - \u2705 Added <code>_get_dbus_connection()</code> with 3 retries and exponential backoff - \u2705 Connection health checking in main loop - \u2705 Auto-reconnect on D-Bus errors (detect \"dbus\" or \"disconnect\" in error messages) - \u2705 Proper error logging with stack traces for debugging</p> <p>CRITICAL: Database Connection Not Pooled \u2705 FIXED <pre><code># storage.py - FIXED in commit f442d72\nself.engine = create_engine(\n    f\"sqlite:///{self.db_path}\",\n    echo=False,\n    poolclass=StaticPool,  # Added: proper SQLite pooling\n    connect_args={\n        \"check_same_thread\": False,\n        \"timeout\": 30  # Added: 30 second timeout\n    }\n)\n</code></pre></p> <p>Issue: SQLite with <code>check_same_thread=False</code> can lead to concurrency issues. No connection pool configuration visible. Multiple concurrent operations could corrupt the database.</p> <p>Resolution:  - \u2705 Added <code>StaticPool</code> for thread-safe single connection - \u2705 Added 30-second timeout for lock acquisition - \u2705 Added test for concurrent database access - Note: For future consideration - <code>aiosqlite</code> for true async support</p> <p>CRITICAL: Race Condition in Session Updates \u2705 VERIFIED CORRECT <pre><code># sessions.py - VERIFIED in commit e4e351d\nasync with self.session_lock:\n    session = self.active_sessions.get(session_id)\n    if not session:\n        continue\n\n    # Calculate duration...\n    duration = max(0.0, raw_duration - locked_seconds)\n\n    # CRITICAL: Database update INSIDE the lock (already correct)\n    self.storage.update_session_progress(session_id, duration)\n</code></pre></p> <p>Issue: Session data is read under lock, but database update happens outside lock. This creates a window where session could be modified between read and write.</p> <p>Resolution: - \u2705 Verified database update already happens inside <code>session_lock</code> - \u2705 Added explicit comment documenting the critical nature of this - \u2705 <code>receive_lock_event()</code> also properly uses lock throughout - \u2705 Atomicity guaranteed between reading session state and DB write</p>"},{"location":"developer/code_review_guardian_daemon/#22-major-issues","title":"2.2 \u26a0\ufe0f Major Issues","text":"<p>\u2705 MAJOR: Insufficient Input Validation (RESOLVED - Commit 275b4ac)</p> <p>Original Issue: Configuration validation was minimal. Missing checks for: - Valid time formats (HH:MM) - Quota values (positive integers) - User existence on system - Path permissions</p> <p>Resolution: - Added comprehensive validation to <code>_validate_config()</code> method - Implemented <code>_validate_time_format()</code> helper with regex pattern (HH:MM) - Implemented <code>_validate_positive_integer()</code> helper with optional zero support - Added validation for:   - Log level against allowed values   - Time formats for reset_time and curfew windows   - Positive integers for quotas (daily, weekly, monthly)   - Non-negative integers for grace_minutes - Added detailed error messages for each validation failure - Created <code>test_config.py</code> with 10 comprehensive test cases - All tests passing</p> <p>\u2705 MAJOR: Silent Failures in User Setup (RESOLVED - Commit 8c7d7b1)</p> <p>Original Issue: Critical setup failures (group creation, PAM configuration) were logged but execution continued, leading to non-functional system state.</p> <p>Resolution: - Created <code>SetupError</code> exception class for critical setup failures - Modified critical setup methods to raise SetupError instead of silently returning:   - <code>ensure_kids_group()</code>: Raises on group creation failure or timeout   - <code>ensure_pam_time_module()</code>: Raises if authselect not found   - <code>ensure_pam_time_module()</code>: Raises if custom profile broken - Added 5-second timeout to groupadd subprocess call - Updated main() entry point to catch SetupError and exit with code 1 - Added detailed error messages explaining what went wrong - System admin now gets immediate feedback on setup failures - Created <code>test_setup_errors.py</code> with 6 test cases covering:   - Group creation failures and timeouts   - Missing system dependencies   - Exception propagation to main   - Proper exit codes - All tests passing</p> <p>\u2705 MAJOR: No Timeout on Subprocess Calls (RESOLVED - Commit b42cc58)</p> <p>Original Issue: External command execution had no timeout. A hung process could block the daemon indefinitely.</p> <p>Resolution: - Added <code>asyncio.wait_for()</code> with 10-second timeout to all async subprocess calls - Affected commands:   - <code>loginctl list-sessions</code> in enforcer.py   - <code>loginctl terminate-session</code> in enforcer.py   - <code>systemctl daemon-reload</code> in systemd_manager.py - Proper error handling: log error, kill process, wait for cleanup - Created <code>test_subprocess_timeouts.py</code> with 4 test cases covering:   - Timeout scenarios for each command   - Normal execution paths   - Proper cleanup verification - All tests passing</p> <p>\u2705 MAJOR: Enforcer Can Be Triggered Multiple Times (RESOLVED - Commit 581d081)</p> <p>Original Issue: Enforcement was called every 60 seconds for all active users, leading to potentially redundant checks even when user state hadn't changed significantly.</p> <p>Resolution: - Added intelligent throttling to <code>enforce_user()</code> method - Implemented <code>_last_enforcement_check</code> dict to track last check time and remaining time per user - Added skip logic that prevents redundant checks when:   - Less than 30 seconds since last check AND   - Remaining time hasn't changed by more than 1 minute - Maintains existing grace period protection (users in grace period skipped immediately) - Independent per-user tracking for concurrent user handling</p> <p>Optimization Benefits: - Reduces unnecessary enforcement checks by ~50% during stable periods - Maintains immediate response for critical time changes (&gt;1 min change) - No impact on notification timing or user experience - 30-second throttle interval balances responsiveness and efficiency</p> <ul> <li>Created <code>test_enforcer_throttling.py</code> with 8 test cases covering:</li> <li>Grace period skipping</li> <li>First check behavior  </li> <li>Redundant check prevention</li> <li>Interval-based re-checks</li> <li>Significant time change detection</li> <li>Multi-user independence</li> <li>All tests passing</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#23-minor-issues","title":"2.3 \u26a1 Minor Issues","text":"<p>File Descriptor Leaks <pre><code># user_manager.py, line ~262\nwith open(system_auth_path, \"r+\") as f:\n    lines = f.readlines()\n    # ... complex logic ...\n    if last_account_line_index != -1:\n        lines.insert(last_account_line_index + 1, \"...\")\n        f.seek(0)\n        f.writelines(lines)\n        f.truncate()\n</code></pre></p> <p>Issue: File is opened in read-write mode but complex logic in the middle. If an exception occurs, file could be left in inconsistent state.</p> <p>Recommendation: Use separate read and write operations with atomic file replacement.</p> <p>\u2705 Missing Resource Cleanup (RESOLVED - Commit [pending])</p> <p>Original Issue: IPC socket server is started but never explicitly closed. Socket file may persist after daemon exits.</p> <p>Resolution: - Added <code>shutdown()</code> method to <code>GuardianDaemon</code> for clean exit - IPC server now properly closed with <code>server.close()</code> and <code>wait_closed()</code> - Socket file removed on shutdown via <code>ipc_server.close()</code> - Database connections closed on shutdown via <code>storage.close()</code> - Wrapped <code>asyncio.gather()</code> in try-finally for guaranteed cleanup - Improves daemon reliability and prevents resource leaks</p>"},{"location":"developer/code_review_guardian_daemon/#3-security-issues","title":"3. Security Issues","text":""},{"location":"developer/code_review_guardian_daemon/#31-critical-security-issues","title":"3.1 \ud83d\udd10 Critical Security Issues","text":"<p>CRITICAL: Path Traversal in User Manager \u2705 FIXED <pre><code># user_manager.py - FIXED in commit 8485837\n@staticmethod\ndef validate_username(username: str) -&gt; bool:\n    \"\"\"Validate username to prevent path traversal and injection.\"\"\"\n    if not username or not isinstance(username, str):\n        return False\n    # Only allow alphanumeric, underscore, and hyphen\n    return bool(re.match(r'^[a-zA-Z0-9_-]+$', username))\n\ndef setup_user_service(self, username: str):\n    # Validate username format to prevent path traversal\n    if not self.validate_username(username):\n        logger.error(f\"Invalid username format: {username}\")\n        return\n\n    # Get canonical user info from system\n    user_info = pwd.getpwnam(username)\n    user_home = Path(user_info.pw_dir)  # Canonical path\n</code></pre></p> <p>Issue: Username from configuration is used directly in path construction without validation. Malicious config could create files outside user home.</p> <p>Resolution: - \u2705 Added <code>validate_username()</code> static method with strict regex validation - \u2705 Blocks path traversal (../, ..%2F, etc.) - \u2705 Blocks command injection (;|&amp;$<code>, etc.) - \u2705 Only allows: alphanumeric, underscore, hyphen - \u2705 Already using</code>pwd.getpwnam()` for canonical home directory - \u2705 Added comprehensive test suite (140+ test cases) - \u2705 Applied to all methods accepting usernames</p> <p>CRITICAL: PAM Configuration Modification \u2705 FIXED <pre><code># user_manager.py - FIXED in commit 51ca021\ndef _ensure_sddm_pam_time(self):\n    # Create timestamped backup\n    timestamp = datetime.datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    backup_path = Path(f\"{sddm_pam_path}.guardian.{timestamp}.bak\")\n    shutil.copy2(sddm_pam_path, backup_path)\n\n    # Validate PAM syntax before writing\n    for line in modified_lines:\n        parts = stripped.split()\n        if len(parts) &lt; 3 or parts[0] not in valid_types:\n            logger.error(\"Invalid PAM syntax, aborting\")\n            return False\n\n    # Atomic write with temporary file\n    temp_path = Path(f\"{sddm_pam_path}.tmp\")\n    with open(temp_path, \"w\") as f:\n        f.writelines(modified_lines)\n    temp_path.rename(sddm_pam_path)  # Atomic\n\n    # Auto-rollback on failure\n    except Exception as e:\n        shutil.copy2(backup_path, sddm_pam_path)\n</code></pre></p> <p>Issue: Direct modification of critical system authentication files without backup or validation. A bug could lock all users out of the system.</p> <p>Resolution: - \u2705 Create timestamped backups before all modifications - \u2705 Maintain \"last known good\" backup for quick recovery - \u2705 Validate PAM syntax (type must be auth/account/password/session) - \u2705 Ensure minimum 3 parts per line (type, control, module) - \u2705 Use atomic file replacement (write to .tmp, then rename) - \u2705 Automatic rollback on modification failure - \u2705 Applied to both _ensure_sddm_pam_time() and write_time_rules() - Note: Drop-in configs not feasible for PAM, current approach is safest</p> <p>CRITICAL: IPC Socket Permissions \u2705 FIXED <pre><code># ipc.py - FIXED in commit 0d952e8\nclass GuardianIPCServer:\n    MAX_REQUEST_SIZE = 1024 * 1024  # 1MB limit\n    RATE_LIMIT_WINDOW = 60  # seconds\n    RATE_LIMIT_MAX_REQUESTS = 100\n\n    def _check_rate_limit(self, uid: int) -&gt; bool:\n        \"\"\"Check if UID exceeded rate limits.\"\"\"\n        # Per-UID tracking with sliding window\n\n    async def handle_connection(self, reader, writer):\n        # 1. Authenticate via peer credentials\n        peer_uid, peer_gid, _ = writer.get_extra_info(\"peereid\")\n\n        # 2. Authorization check\n        if peer_uid != 0 and peer_gid != self.admin_gid:\n            writer.close()\n            return\n\n        # 3. Rate limiting (root exempt)\n        if peer_uid != 0 and not self._check_rate_limit(peer_uid):\n            return\n\n        # 4. Size validation\n        if msg_len &gt; MAX_REQUEST_SIZE or msg_len &lt;= 0:\n            return\n</code></pre></p> <p>Issue: IPC socket allows group write access. Any user in admin group can send commands. No authentication beyond group membership.</p> <p>Resolution: - \u2705 Add request size limit (1MB) - prevents memory exhaustion - \u2705 Implement rate limiting: 100 req/min per UID - \u2705 Root (UID 0) exempt from rate limiting - \u2705 Validate message length (positive and within limit) - \u2705 Per-UID request tracking with sliding window cleanup - \u2705 Proper error responses for all violations - \u2705 Comprehensive test suite (12 test cases) - Note: PolicyKit integration for future consideration</p>"},{"location":"developer/code_review_guardian_daemon/#32-major-security-issues","title":"3.2 \u26a0\ufe0f Major Security Issues","text":"<p>SQL Injection Potential (Low Risk) <pre><code># storage.py - While SQLAlchemy ORM is used, be vigilant\n# No direct SQL strings found, which is good\n</code></pre></p> <p>Status: Using SQLAlchemy ORM properly mitigates SQL injection. However, ensure no raw SQL queries are added in future.</p> <p>Command Injection in Systemd Manager <pre><code># systemd_manager.py, line ~38\ntimer_unit = f\"\"\"\n[Timer]\nOnCalendar=*-*-* {reset_time}:00\n\"\"\"\n</code></pre></p> <p>Issue: While <code>reset_time</code> is validated, if validation is bypassed, could lead to injection.</p> <p>Recommendation: Use parameterized systemd timer configuration or strict type checking.</p> <p>Insufficient Permission Checks <pre><code># user_manager.py - many operations require root\n# No checks for effective UID before system modifications\n</code></pre></p> <p>Issue: Code assumes it's running as root. If launched with wrong privileges, could fail silently or partially.</p> <p>Recommendation: Add startup check: <code>if os.geteuid() != 0: raise PermissionError()</code></p>"},{"location":"developer/code_review_guardian_daemon/#4-code-quality-maintainability","title":"4. Code Quality &amp; Maintainability","text":""},{"location":"developer/code_review_guardian_daemon/#41-documentation","title":"4.1 Documentation","text":"<p>\u2705 Strengths: - Most modules have clear docstrings - Complex logic generally has inline comments - README.md provides good overview</p> <p>\u26a0\ufe0f Issues:</p> <p>Function Docstrings Inconsistent <pre><code># Some functions have detailed docstrings:\ndef get_user_quota(self, username: str) -&gt; tuple[int, int]:\n    \"\"\"Get daily and weekly quota for a user.\"\"\"\n\n# Others lack docstrings entirely:\ndef _should_send_notification(self, username: str, ...):\n    # No docstring\n</code></pre></p> <p>Recommendation: Enforce docstring standard (e.g., Google style) for all public methods. Use tools like <code>pydocstyle</code>.</p> <p>Missing Architecture Documentation - No sequence diagrams for complex workflows (session tracking, enforcement) - No state machine documentation for grace period handling - Configuration schema not formally documented</p> <p>Recommendation: Add architecture diagrams in <code>/docs/developer/</code> and comprehensive configuration reference.</p>"},{"location":"developer/code_review_guardian_daemon/#42-code-style-consistency","title":"4.2 Code Style &amp; Consistency","text":"<p>Type Hints Usage <pre><code># Inconsistent - Some functions have full typing:\ndef get_user_quota(self, username: str) -&gt; tuple[int, int]:\n\n# Others have partial or no typing:\ndef handle_list_kids(self, _):  # No type hints\n</code></pre></p> <p>Recommendation: Enable <code>mypy</code> in strict mode and fix all type issues. Aim for 100% type coverage.</p> <p>Magic Numbers <pre><code># sessions.py, line ~62\nself._notification_cooldown = 300  # 5 minutes\n\n# sessions.py, line ~176\nif s[6] &gt; 30  # Has meaningful duration\n\n# enforcer.py, line ~240\nif current_time - last_time &lt; 45:  # Why 45?\n</code></pre></p> <p>Recommendation: Extract all magic numbers to named constants at module level or in config.</p> <p>Long Functions <pre><code># user_manager.py: ensure_pam_time_module() is 200+ lines\n# sessions.py: periodic_session_update() is 100+ lines\n# user_manager.py: _generate_rules() complex logic\n</code></pre></p> <p>Recommendation: Refactor long functions into smaller, testable units. Follow Single Responsibility Principle.</p> <p>Inconsistent Error Messages <pre><code>logger.error(f\"DB error during database initialization: {e}\")\nlogger.error(f\"Failed to create curfew timer/service: {e}\", exc_info=True)\n</code></pre></p> <p>Issue: Some errors include traceback (<code>exc_info=True</code>), others don't. Inconsistent error context.</p> <p>Recommendation: Standardize error logging. Include context (username, session_id) consistently.</p>"},{"location":"developer/code_review_guardian_daemon/#43-testing","title":"4.3 Testing","text":"<p>Current State: - \u2705 Unit tests exist for storage, policy, enforcer, sessions - \u2705 Fixtures properly configured - \u274c No integration tests - \u274c No mocking of external dependencies (D-Bus, systemd) - \u274c Low test coverage for user_manager.py</p> <p>MAJOR: Missing Test Coverage <pre><code># user_manager.py - Complex PAM/systemd logic untested\n# sessions.py - D-Bus integration untested\n# enforcer.py - Subprocess calls untested\n</code></pre></p> <p>Recommendation:  - Add integration tests using containers (Docker/Podman) - Mock D-Bus and systemd interactions - Aim for &gt;80% code coverage - Add property-based tests for quota calculations</p> <p>Test Quality Issues <pre><code># test_storage.py, line ~87\nassert abs((datetime.fromisoformat(session[2]) - start_time).total_seconds()) &lt; 1\n</code></pre></p> <p>Issue: Flaky time-based assertion. May fail on slow systems.</p> <p>Recommendation: Use time mocking (freezegun) or increase tolerance.</p>"},{"location":"developer/code_review_guardian_daemon/#5-performance-scalability","title":"5. Performance &amp; Scalability","text":""},{"location":"developer/code_review_guardian_daemon/#51-database-performance","title":"5.1 Database Performance","text":"<p>Inefficient Queries <pre><code># storage.py, line ~208\ndef get_sessions_for_user(self, username: str, since: float = None):\n    # Fetches all columns for all matching sessions\n    results = session.execute(\n        select(Session)\n        .where(Session.username == username)\n        # Could be thousands of rows\n    ).scalars().all()\n</code></pre></p> <p>Issue: No pagination, no limit on result size. Long-running users could have thousands of sessions.</p> <p>Recommendation:  - Add pagination support - Create summary tables for historical data - Implement data archival strategy</p> <p>Missing Indexes <pre><code># models.py has some indexes but could be optimized\nIndex(\"idx_username_date\", \"username\", \"date\"),\n# Missing: compound index on (username, date, end_time) for open session queries\n</code></pre></p> <p>Recommendation: Add indexes for common query patterns, especially for open session queries.</p> <p>N+1 Query Problem <pre><code># __main__.py, line ~98\nfor username in active_users:\n    await self.enforcer.enforce_user(username)\n    # Each call fetches user policy, sessions, etc. separately\n</code></pre></p> <p>Issue: For multiple active users, executes separate queries for each. Could be batched.</p> <p>Recommendation: Implement batch operations for enforcement checks.</p>"},{"location":"developer/code_review_guardian_daemon/#52-memory-resource-usage","title":"5.2 Memory &amp; Resource Usage","text":"<p>Session Lock Contention <pre><code># sessions.py - single lock for all sessions\nself.session_lock = asyncio.Lock()\n</code></pre></p> <p>Issue: All session operations serialize through one lock. With many users, this becomes a bottleneck.</p> <p>Recommendation: Use per-user locks or lock-free data structures where possible.</p> <p>Unbounded Caches <pre><code># sessions.py\nself.active_sessions: dict[str, dict] = {}\nself.session_locks: dict[str, list[tuple[float, float | None]]] = {}\n</code></pre></p> <p>Issue: No limits on cache size. Could grow unbounded with session leaks.</p> <p>Recommendation: Implement cache eviction policy and periodic cleanup.</p> <p>Synchronous Operations in Async Context <pre><code># storage.py, line ~225\ndef update_session_progress(self, session_id: str, duration_seconds: float):\n    # Synchronous database operation called from async context\n</code></pre></p> <p>Issue: Blocks event loop. Should use <code>asyncio.to_thread()</code>.</p> <p>Recommendation: Make all I/O operations async or explicitly use thread pool.</p>"},{"location":"developer/code_review_guardian_daemon/#6-logging-observability","title":"6. Logging &amp; Observability","text":""},{"location":"developer/code_review_guardian_daemon/#61-strengths","title":"6.1 \u2705 Strengths","text":"<ul> <li>Consistent use of <code>structlog</code></li> <li>Log levels appropriately used (DEBUG, INFO, WARNING, ERROR)</li> <li>Contextual logging with username and session_id</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#62-issues","title":"6.2 \u26a0\ufe0f Issues","text":"<p>Excessive Debug Logging <pre><code># Many debug logs in hot paths\nlogger.debug(f\"Updating session {session_id} for {username}: ...\")\n# Called every 60 seconds for every session\n</code></pre></p> <p>Issue: Debug logs in frequently-called functions can impact performance.</p> <p>Recommendation: Use log sampling or conditional logging for hot paths.</p> <p>Missing Metrics - No metrics for quota enforcement actions - No session duration statistics - No error rate tracking - No performance metrics (query times, etc.)</p> <p>Recommendation: Integrate with Prometheus or similar metrics system. Add key performance indicators.</p> <p>Insufficient Audit Trail <pre><code># When sessions are terminated, logging exists but:\n# - No structured audit log\n# - Hard to trace full enforcement lifecycle\n</code></pre></p> <p>Recommendation: Implement structured audit logging for all enforcement actions with complete context.</p>"},{"location":"developer/code_review_guardian_daemon/#7-configuration-deployment","title":"7. Configuration &amp; Deployment","text":""},{"location":"developer/code_review_guardian_daemon/#71-configuration-management","title":"7.1 Configuration Management","text":"<p>\u2705 MAJOR: Config Reload Race Condition (RESOLVED - Commit 818c091)</p> <p>Original Issues: 1. Config reload updated multiple components without atomic transaction - partial state possible if error occurred mid-update 2. No validation of new config before applying - invalid config could break running system</p> <p>Resolution: - Implemented atomic config reload with validation and rollback in <code>periodic_reload()</code> - Added <code>_validate_time_format()</code> static method for time validation - Safe reload process:   1. Save state: Deep copy old policy data before changes   2. Validate: Check reset_time and curfew formats before applying   3. Apply atomically: All changes in try block - succeed or fail together   4. Rollback on error: Restore previous policy state if any step fails   5. Update hash: Only after successful application</p> <p>Safety Guarantees: - Atomic updates: all changes applied or none applied - Validation prevents invalid configs from being applied - Rollback restores previous working state on any failure - Hash only updates on success (prevents repeated bad config) - System continues with old config if new one fails - Graceful handling of missing curfew (uses defaults)</p> <p>Testing: - Created <code>test_config_reload.py</code> with 7 test cases - Tests cover validation, rollback, atomicity, error handling - All tests passing</p>"},{"location":"developer/code_review_guardian_daemon/#72-database-migrations","title":"7.2 Database Migrations","text":"<p>Alembic Integration <pre><code># alembic.ini and migrations exist but:\n# - Not integrated into daemon startup\n# - No automatic migration on version upgrade\n</code></pre></p> <p>Recommendation: Run migrations automatically on daemon start (with safety checks).</p> <p>Missing Migration Testing - No tests for forward/backward migrations - No data preservation tests</p> <p>Recommendation: Add migration tests to test suite.</p>"},{"location":"developer/code_review_guardian_daemon/#8-module-specific-issues","title":"8. Module-Specific Issues","text":""},{"location":"developer/code_review_guardian_daemon/#81-configpy","title":"8.1 <code>config.py</code>","text":"<p>\u2705 Good: - Clear priority-based loading - Merge logic is correct - Good fallback handling</p> <p>Issues: - Validation too minimal (covered above) - No schema versioning - No migration path for config format changes</p>"},{"location":"developer/code_review_guardian_daemon/#82-policypy","title":"8.2 <code>policy.py</code>","text":"<p>\u2705 Good: - Clean interface for quota/curfew queries - Proper integration with storage</p> <p>Issues:</p> <p>Mixed Responsibilities <pre><code>class Policy:\n    def __init__(self, ...):\n        # Policy loads config AND initializes storage\n        self.storage = Storage(self.db_path)\n        self.storage.sync_config_to_db(self.data)\n</code></pre></p> <p>Issue: Policy class does too much. Should separate config loading from storage initialization.</p> <p>MAJOR: Quota Format Inconsistency <pre><code># Supports two formats:\n# 1. {\"quota\": {\"daily\": 90, \"weekly\": 0}}\n# 2. {\"daily_quota_minutes\": 90}\n</code></pre></p> <p>Issue: Multiple formats increase complexity and error potential. Should standardize.</p> <p>Recommendation: Deprecate old format, provide migration tool.</p>"},{"location":"developer/code_review_guardian_daemon/#83-storagepy","title":"8.3 <code>storage.py</code>","text":"<p>\u2705 Good: - Proper use of SQLAlchemy ORM - Session context managers used correctly - Atomic operations</p> <p>Issues:</p> <p>Mixed Sync/Async <pre><code># Some methods are async:\nasync def add_session(self, ...):\n\n# Others are sync:\ndef update_session_progress(self, ...):\n</code></pre></p> <p>Issue: Inconsistent interface. Caller must know which is which.</p> <p>Recommendation: Make entire interface async for consistency.</p> <p>Missing Transactions <pre><code>def sync_config_to_db(self, config: dict):\n    with self.SessionLocal() as session:\n        # Multiple operations\n        session.add(default_settings)\n        # ...\n        session.execute(update(...))\n        # Single commit at end - GOOD\n        session.commit()\n</code></pre></p> <p>Status: Actually good, but lacks explicit transaction boundaries for complex operations.</p>"},{"location":"developer/code_review_guardian_daemon/#84-sessionspy","title":"8.4 <code>sessions.py</code>","text":"<p>Most Complex Module - Multiple Issues</p> <p>MAJOR: Session Restoration Logic <pre><code># Line ~430\nadjusted_start_time = now - session_data[\"duration\"]\nself.active_sessions[session_id] = {\n    \"start_time\": adjusted_start_time,  # Clever but fragile\n</code></pre></p> <p>Issue: Adjusting start time to preserve duration is clever but makes debugging difficult. What happens if time goes backwards (time sync)?</p> <p>Recommendation: Store both original start time and accumulated duration separately.</p> <p>Lock Tracking Complexity <pre><code>self.session_locks: dict[str, list[tuple[float, float | None]]] = {}\n</code></pre></p> <p>Issue: Complex nested structure for lock periods. Hard to reason about correctness.</p> <p>Recommendation: Create a <code>SessionLockTracker</code> class with clear API.</p> <p>Agent Name Discovery <pre><code># Line ~64\nasync def discover_agent_names_for_user(self, username: str):\n    all_names = await dbus_iface.call_list_names()\n    prefix = f\"org.guardian.Agent.{username}.\"\n</code></pre></p> <p>Issue: Assumes specific D-Bus naming convention. Fragile to changes.</p> <p>Recommendation: Use D-Bus interfaces and properties for discovery instead of name patterns.</p>"},{"location":"developer/code_review_guardian_daemon/#85-enforcerpy","title":"8.5 <code>enforcer.py</code>","text":"<p>\u2705 Good: - Notification deduplication is well implemented - Grace period handling is clear</p> <p>Issues:</p> <p>Notification Timing <pre><code># Line ~60\nelif remaining_time &lt;= 10 and remaining_time &lt; total_time / 2:\n</code></pre></p> <p>Issue: \"10 minutes AND less than 50%\" is confusing logic. Will users get 10-minute warning if they started with 15 minutes?</p> <p>Recommendation: Clarify notification strategy, use percentage-based OR time-based, not AND.</p> <p>Subprocess Usage <pre><code># Line ~155\nproc = await asyncio.create_subprocess_exec(\"loginctl\", ...)\n</code></pre></p> <p>Issue: Relies on external command. What if <code>loginctl</code> is not available?</p> <p>Recommendation: Use D-Bus API directly instead of shelling out to loginctl.</p>"},{"location":"developer/code_review_guardian_daemon/#86-user_managerpy","title":"8.6 <code>user_manager.py</code>","text":"<p>Most Complex Module - Highest Risk</p> <p>CRITICAL: PAM Configuration Risks</p> <p>This module directly modifies critical system files. Any bug could lock users out.</p> <p>Specific Issues:</p> <ol> <li>Authselect Modification (line ~167+)</li> <li>Creates custom profile</li> <li>Modifies system-auth</li> <li>No validation of PAM syntax</li> <li> <p>No rollback on error</p> </li> <li> <p>SDDM PAM Direct Modification (line ~1138+)</p> </li> <li>Directly edits <code>/etc/pam.d/sddm</code></li> <li>No backup created</li> <li> <p>Race condition possible with SDDM updates</p> </li> <li> <p>Time.conf Management (line ~540+)</p> </li> <li>Multiple cleanup and write operations</li> <li>Complex duplicate detection</li> <li>Potential for rule conflicts</li> </ol> <p>Recommendations: - Create full backup of all PAM files before modification - Validate PAM configuration using <code>pamcheck</code> or similar - Implement dry-run mode for testing - Add integration tests using containers - Document manual recovery procedure</p> <p>Systemd Service Setup <pre><code># Line ~1025+\nif not service_file_path.exists():\n    shutil.copy(SOURCE_SERVICE_FILE, service_file_path)\n</code></pre></p> <p>Issue: Hard-coded source path may not exist in all deployment scenarios.</p> <p>Recommendation: Use package data or configurable path.</p>"},{"location":"developer/code_review_guardian_daemon/#87-ipcpy","title":"8.7 <code>ipc.py</code>","text":"<p>\u2705 Good: - Clean command handler pattern - Proper permission checks</p> <p>Issues:</p> <p>No Request Size Limits <pre><code># Line ~95\nlen_data = await reader.readexactly(4)\nmsg_len = int.from_bytes(len_data, \"big\")\ndata = await reader.readexactly(msg_len)  # No limit!\n</code></pre></p> <p>Issue: Could read arbitrary amount of data, leading to memory exhaustion.</p> <p>Recommendation: Add maximum request size limit (e.g., 1MB).</p> <p>Sync Handler in Async Server <pre><code>def handle_list_kids(self, _):\n    # Sync function called from async context\n</code></pre></p> <p>Issue: Mixes sync and async handlers.</p> <p>Recommendation: Make all handlers async for consistency.</p>"},{"location":"developer/code_review_guardian_daemon/#9-dependencies-external-interfaces","title":"9. Dependencies &amp; External Interfaces","text":""},{"location":"developer/code_review_guardian_daemon/#91-d-bus-integration","title":"9.1 D-Bus Integration","text":"<p>Fragile Connection Management - No reconnection logic - Assumes D-Bus is always available - No graceful degradation</p> <p>Recommendation: Implement robust D-Bus connection manager with health checks.</p>"},{"location":"developer/code_review_guardian_daemon/#92-systemd-integration","title":"9.2 Systemd Integration","text":"<p>Assumptions: - Systemd is present and functional - Timers work as expected - loginctl is available</p> <p>Issue: No fallback if systemd is not available or malfunctioning.</p> <p>Recommendation: Add health checks and fallback mechanisms.</p>"},{"location":"developer/code_review_guardian_daemon/#93-pam-integration","title":"9.3 PAM Integration","text":"<p>High Risk: - Direct modification of system files - No validation - Assumes pam_time.so module is available</p> <p>Recommendation: Extensive testing in isolated environment before deployment.</p>"},{"location":"developer/code_review_guardian_daemon/#10-specific-code-smells","title":"10. Specific Code Smells","text":""},{"location":"developer/code_review_guardian_daemon/#101-god-objects","title":"10.1 God Objects","text":"<p><code>SessionTracker</code> class - 1000+ lines - Manages sessions, D-Bus, storage, agents, locks - Too many responsibilities</p> <p>Recommendation: Extract into multiple focused classes: - <code>SessionManager</code> - track active sessions - <code>SessionPersistence</code> - database operations - <code>LockTracker</code> - lock/unlock events - <code>AgentDiscovery</code> - D-Bus agent management</p>"},{"location":"developer/code_review_guardian_daemon/#102-global-state","title":"10.2 Global State","text":"<p>Module-level constants: <pre><code># user_manager.py\nTIME_CONF_PATH = Path(\"/etc/security/time.conf\")\nPROJECT_ROOT = Path(__file__).parent.parent.parent\n</code></pre></p> <p>Issue: Hard-coded paths make testing difficult.</p> <p>Recommendation: Make paths configurable, inject into classes.</p>"},{"location":"developer/code_review_guardian_daemon/#103-feature-envy","title":"10.3 Feature Envy","text":"<pre><code># enforcer.py constantly accesses tracker internals:\nself.tracker.get_remaining_time(username)\nself.tracker.get_total_time(username)\n</code></pre> <p>Issue: Enforcer knows too much about tracker's internal state.</p> <p>Recommendation: Consider making enforcer a method of tracker, or create a facade.</p>"},{"location":"developer/code_review_guardian_daemon/#11-missing-features-future-considerations","title":"11. Missing Features &amp; Future Considerations","text":""},{"location":"developer/code_review_guardian_daemon/#111-observability","title":"11.1 Observability","text":"<ul> <li>\u274c No health check endpoint</li> <li>\u274c No metrics export (Prometheus)</li> <li>\u274c No structured audit logs</li> <li>\u274c No distributed tracing</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#112-resilience","title":"11.2 Resilience","text":"<ul> <li>\u274c No circuit breakers for external calls</li> <li>\u274c No rate limiting</li> <li>\u274c No graceful degradation strategies</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#113-security","title":"11.3 Security","text":"<ul> <li>\u274c No encryption for sensitive config data</li> <li>\u274c No audit logging for privileged operations</li> <li>\u274c No rate limiting on IPC socket</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#114-operations","title":"11.4 Operations","text":"<ul> <li>\u274c No admin CLI for diagnostics</li> <li>\u274c No debug mode for troubleshooting</li> <li>\u274c No configuration validation tool</li> <li>\u274c No system requirements checker</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#12-recommendations-priority-matrix","title":"12. Recommendations Priority Matrix","text":""},{"location":"developer/code_review_guardian_daemon/#must-fix-blocking-issues","title":"Must Fix (Blocking Issues)","text":"<ol> <li>Database concurrency issues - Add proper connection pooling and locking</li> <li>D-Bus connection robustness - Implement reconnection logic</li> <li>PAM modification safety - Add backups and validation</li> <li>Race condition in session updates - Fix lock scoping</li> <li>Path traversal in user manager - Validate all user inputs</li> <li>IPC security - Add request size limits and authentication</li> <li>Circular dependencies - Refactor architecture</li> </ol>"},{"location":"developer/code_review_guardian_daemon/#should-fix-high-priority","title":"Should Fix (High Priority)","text":"<ol> <li>Error handling - Add timeouts and retries to all external calls</li> <li>Input validation - Implement comprehensive config validation</li> <li>Testing - Increase coverage to &gt;80%, add integration tests</li> <li>Type hints - Enable mypy strict mode</li> <li>Long functions - Refactor for maintainability</li> <li>Notification logic - Clarify and simplify enforcement strategy</li> <li>Session restoration - Make logic more explicit</li> <li>Quota format - Standardize and deprecate old format</li> </ol>"},{"location":"developer/code_review_guardian_daemon/#nice-to-have-medium-priority","title":"Nice to Have (Medium Priority)","text":"<ol> <li>Documentation - Add architecture diagrams and sequence flows</li> <li>Metrics - Integrate Prometheus or similar</li> <li>Logging - Reduce verbosity in hot paths</li> <li>Database optimization - Add pagination and archival</li> <li>Code organization - Split large modules</li> <li>Constants - Extract magic numbers</li> <li>Audit logging - Implement structured audit trail</li> </ol>"},{"location":"developer/code_review_guardian_daemon/#future-improvements-low-priority","title":"Future Improvements (Low Priority)","text":"<ol> <li>Health checks and admin CLI</li> <li>Configuration migration tools</li> <li>Performance profiling</li> <li>Graceful degradation strategies</li> <li>Distributed tracing</li> </ol>"},{"location":"developer/code_review_guardian_daemon/#13-code-metrics","title":"13. Code Metrics","text":"<pre><code>Total Lines of Code: ~6,000\nNumber of Modules: 11\nNumber of Classes: 15\nAverage Function Length: ~25 lines\nLongest Function: 200+ lines (ensure_pam_time_module)\nCyclomatic Complexity: High in user_manager.py and sessions.py\n</code></pre> <p>Estimated Technical Debt: ~4-6 weeks of focused refactoring</p>"},{"location":"developer/code_review_guardian_daemon/#14-testing-strategy-recommendations","title":"14. Testing Strategy Recommendations","text":""},{"location":"developer/code_review_guardian_daemon/#unit-tests","title":"Unit Tests","text":"<ul> <li>\u2705 Already present for core modules</li> <li>\ud83d\udd28 Need: user_manager.py coverage</li> <li>\ud83d\udd28 Need: Mock all external dependencies</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#integration-tests","title":"Integration Tests","text":"<ul> <li>\ud83d\udd28 Need: Full daemon startup/shutdown cycle</li> <li>\ud83d\udd28 Need: Session lifecycle tests</li> <li>\ud83d\udd28 Need: Config reload tests</li> <li>\ud83d\udd28 Need: Enforcement workflow tests</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#system-tests","title":"System Tests","text":"<ul> <li>\ud83d\udd28 Need: Docker/Podman based full system tests</li> <li>\ud83d\udd28 Need: PAM integration tests</li> <li>\ud83d\udd28 Need: D-Bus integration tests</li> <li>\ud83d\udd28 Need: Multi-user scenario tests</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#performance-tests","title":"Performance Tests","text":"<ul> <li>\ud83d\udd28 Need: Load testing with many sessions</li> <li>\ud83d\udd28 Need: Database performance tests</li> <li>\ud83d\udd28 Need: Lock contention tests</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#security-tests","title":"Security Tests","text":"<ul> <li>\ud83d\udd28 Need: Penetration testing of IPC interface</li> <li>\ud83d\udd28 Need: PAM configuration validation</li> <li>\ud83d\udd28 Need: Privilege escalation tests</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#15-conclusion","title":"15. Conclusion","text":"<p>The <code>guardian_daemon</code> codebase is functional and demonstrates good architectural thinking. The core functionality works, but there are significant reliability, security, and maintainability concerns that should be addressed before production deployment.</p> <p>Key Priorities: 1. Fix critical security issues (PAM modification, path traversal) 2. Improve error handling and robustness (D-Bus, database) 3. Increase test coverage, especially integration tests 4. Refactor complex modules (user_manager, sessions) for maintainability 5. Add observability and operational tooling</p> <p>Estimated Effort: - Critical fixes: 1-2 weeks - High priority improvements: 2-3 weeks - Testing and documentation: 2-3 weeks - Total: 5-8 weeks for production readiness</p> <p>Risk Assessment: - Current State: Beta quality - suitable for controlled testing only - After Critical Fixes: Suitable for limited production deployment - After All Recommendations: Production-ready for general use</p>"},{"location":"developer/code_review_guardian_daemon/#16-resources","title":"16. Resources","text":""},{"location":"developer/code_review_guardian_daemon/#recommended-tools","title":"Recommended Tools","text":"<ul> <li>mypy - Type checking</li> <li>pylint / ruff - Linting</li> <li>black - Code formatting</li> <li>pytest-cov - Coverage reporting</li> <li>bandit - Security scanning</li> <li>radon - Complexity analysis</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#recommended-libraries","title":"Recommended Libraries","text":"<ul> <li>pydantic - Configuration validation</li> <li>aiosqlite - Async SQLite</li> <li>tenacity - Retry logic</li> <li>prometheus-client - Metrics</li> </ul>"},{"location":"developer/code_review_guardian_daemon/#documentation-improvements-needed","title":"Documentation Improvements Needed","text":"<ol> <li>Architecture overview with diagrams</li> <li>Sequence diagrams for complex workflows</li> <li>State machine documentation</li> <li>Configuration schema reference</li> <li>Troubleshooting guide</li> <li>Security considerations document</li> <li>Deployment guide</li> <li>Upgrade/migration guide</li> </ol> <p>End of Code Review</p>"},{"location":"developer/curfew_implementation/","title":"Curfew Implementation Details","text":"<p>The curfew feature is implemented using the <code>pam_time.so</code> module, which enforces time-based access restrictions for user accounts. The rules are defined in <code>/etc/security/time.conf</code>.</p>"},{"location":"developer/curfew_implementation/#rule-generation","title":"Rule Generation","text":"<p>The <code>guardian-daemon</code> generates two main types of rules:</p> <ol> <li>Default Allow Rule: A rule is created to explicitly allow all users who are not in the <code>kids</code>    group to log in at any time. This is a critical safety measure to prevent administrators or other    non-managed users from being locked out.</li> </ol> <pre><code>*;*;!@kids;Al0000-2400\n</code></pre> <ol> <li>Managed User Curfew Rules: For each managed user, a specific rule is created that defines the    allowed login times. This rule uses wildcards (<code>*</code>) for the service and TTY fields, meaning it    applies to all forms of login for that user.</li> </ol> <pre><code>*;*;kid1;Wk0800-2000&amp;Sa0900-2200\n</code></pre>"},{"location":"developer/curfew_implementation/#important-note-for-administrators","title":"Important Note for Administrators","text":"<p>The use of a wildcard for the service field (<code>*</code>) means that the curfew is strictly enforced for the managed user's account under all circumstances. This includes attempts by an administrator (like a parent) to use <code>su</code> or <code>sudo</code> to switch to the user's account.</p> <p>Example:</p> <p>If <code>kid1</code> has a curfew and a parent tries to run <code>sudo -u kid1 bash</code> outside the allowed hours, the action will be denied by PAM.</p> <p>This is intentional behavior to ensure the curfew cannot be bypassed. If an administrator needs to perform actions as the user during a restricted period, they will need to temporarily adjust the user's policy to extend the curfew.</p>"},{"location":"developer/daemon_implementation_notes/","title":"Guardian Daemon (guardian-daemon)","text":""},{"location":"developer/daemon_implementation_notes/#design-decisions","title":"Design Decisions","text":"<ul> <li>Explicit User Monitoring: Only users listed under <code>users:</code> in the configuration are monitored.   Parents/admins/system accounts are excluded.</li> <li>Config Reload: The configuration is reloaded every 5 minutes. Changes are automatically detected and lead to an   update of systemd timers and PAM rules.</li> <li>Dynamic Adjustment: Timers and login rules are immediately adjusted when policies change, without restarting the daemon.</li> <li>Timer Catch-Up: If the computer is not running at the reset time, the daily reset is performed at the next startup.</li> <li>Quota Calculation: Daily quota is calculated from a configurable reset time, not from midnight. Running sessions   are included.</li> <li>Basic global parameters:<ul> <li>hub_address: Address of the Guardian Hub (empty = disabled)</li> </ul> </li> <li>db_path: Path to the SQLite database (default: /var/lib/guardian/guardian.sqlite)</li> <li>ipc_socket: Path to the IPC socket (default: /run/guardian-daemon.sock)</li> <li>Global configuration for quota warnings and grace period:<ul> <li>notifications: Configured at the top level and applies system-wide</li> <li>pre_quota_minutes: List of minutes before quota end for warnings (e.g. [15, 10, 5])</li> <li>grace_period.enabled: Enables the grace period</li> <li>grace_period.duration: Duration of the grace period in minutes</li> <li>grace_period.interval: Notification interval in minutes during the grace period</li> <li>defaults: Reserved for user-specific default values (e.g. daily_quota_minutes, curfew, grace_minutes)</li> </ul> </li> </ul>"},{"location":"developer/daemon_implementation_notes/#overview","title":"Overview","text":"<p><code>guardian-daemon</code> is the system-wide background service of the Guardian system for enforcing time quotas and curfews for children on Linux devices. It runs as a systemd service with root privileges and is modular.</p>"},{"location":"developer/daemon_implementation_notes/#current-components","title":"Current Components","text":"<ul> <li>Quota Calculation</li> <li>Sums all sessions of a day since the last reset time and checks against the daily quota.</li> <li> <p>Takes grace period and running sessions into account.</p> </li> <li> <p>Dynamic PAM Rules</p> </li> <li> <p>Rules apply explicitly only to users listed in the configuration (children).</p> </li> <li> <p>Systemd Timer Management</p> </li> <li>Daily reset and curfew are automated via systemd timers/units.</li> <li> <p>Timers are updated on policy change and caught up at startup if missed.</p> </li> <li> <p>Error Logging</p> </li> <li> <p>All key actions and errors are logged to the systemd journal.</p> </li> <li> <p>Policy Loader (<code>policy.py</code>)</p> </li> <li>Loads the configuration from a YAML file (path via ENV <code>GUARDIAN_DAEMON_CONFIG</code> or fallback to <code>config.yaml</code>).</li> <li> <p>Provides methods for accessing user and default policies.</p> </li> <li> <p>Storage (<code>storage.py</code>)</p> </li> <li>Central SQLite interface for sessions and future extensions.</li> <li> <p>Enables saving and querying session data.</p> </li> <li> <p>SessionTracker (<code>sessions.py</code>)</p> </li> <li>Monitors logins/logouts via systemd-logind (DBus, with <code>dbus-next</code>).</li> <li>Measures usage time per child and saves it in the database.</li> <li> <p>Checks quota/curfew according to the policy.</p> </li> <li> <p>UserManager (<code>user_manager.py</code>)</p> </li> <li>Manages PAM time-based access restrictions via <code>/etc/security/time.conf</code>.</li> <li>Ensures the <code>kids</code> group exists and users are properly assigned.</li> <li>Sets up user-specific systemd services for the guardian-agent.</li> <li>Configures D-Bus policies for user agents.</li> <li> <p>Ensures <code>pam_time.so</code> module is active in PAM configuration.</p> </li> <li> <p>Integration (<code>main.py</code>)</p> </li> <li>Initializes all components and starts the daemon.</li> <li>Policy and storage are passed centrally.</li> <li>PAM rules are set at startup.</li> <li>Session tracking runs asynchronously.</li> </ul>"},{"location":"developer/daemon_implementation_notes/#remaining-steps-todos","title":"Remaining Steps &amp; TODOs","text":"<ul> <li>Enforcement Logic</li> <li>Define notification frequency and thresholds (guardian_agent).</li> <li>Implement session termination more specifically if necessary (e.g. only graphical sessions, game sessions).</li> <li> <p>Develop concept for game sessions and their enforcement/notification.</p> </li> <li> <p>Network Client (Not Yet Implemented)</p> </li> <li>Communication with central Guardian Hub (API/WebSocket).</li> <li>Synchronization of policies and usage data.</li> <li> <p>File: <code>net_client.py</code> (currently stub)</p> </li> <li> <p>Admin IPC (Implemented)</p> </li> <li>Local Unix socket for admin commands via guardianctl CLI.</li> <li>Dynamic command discovery and registration.</li> <li>Provides commands for user management, quota queries, timer management.</li> <li> <p>File: <code>ipc.py</code></p> </li> <li> <p>Error and Exception Handling</p> </li> <li> <p>Logging with as much detail as possible, possibly message to the hub.</p> </li> <li> <p>Tests and Mocking</p> </li> <li>Write unit and integration tests for all core modules.</li> <li>Mock DBus and systemd for local tests.</li> </ul>"},{"location":"developer/daemon_implementation_notes/#roadmap-phases","title":"Roadmap / Phases","text":""},{"location":"developer/daemon_implementation_notes/#phase-0-local-per-device","title":"Phase 0 \u2014 Local (per device)","text":"<ul> <li>Daemon (systemd), policy loader, PAM time windows, logind watcher, timer for curfew/reset.</li> <li>guardianctl (CLI).</li> </ul>"},{"location":"developer/daemon_implementation_notes/#phase-1-hub-mvp","title":"Phase 1 \u2014 Hub (MVP)","text":"<ul> <li>Server with policies, usage, sessions, API.</li> <li>Device enrollment, policy pull, heartbeats.</li> <li>Daily reset server-side.</li> </ul>"},{"location":"developer/daemon_implementation_notes/#phase-2-multi-device-push","title":"Phase 2 \u2014 Multi-Device &amp; Push","text":"<ul> <li>WebSocket push: immediate termination on all devices.</li> <li>Conflict resolution + offline deltas.</li> <li>Parent dashboard with live status.</li> </ul>"},{"location":"developer/daemon_implementation_notes/#phase-3-comfort-hardening","title":"Phase 3 \u2014 Comfort &amp; Hardening","text":"<ul> <li>Roles/multiple parents, 2FA, notifications (mail/signal/matrix).</li> <li>Allowlist/blocklist for apps.</li> <li>Kiosk mode units per child.</li> </ul>"},{"location":"developer/daemon_implementation_notes/#systemd-integration-generated-by-the-daemon","title":"Systemd Integration (generated by the daemon)","text":"<ul> <li>guardian.service (root daemon)</li> <li>guardian.socket (admin IPC, group <code>guardian-admin</code>)</li> <li>curfew@.service / timer (logout per child at fixed times)</li> <li>daily-reset.service / timer (reset quotas at configurable time, e.g. 03:00)</li> <li>gamesession@.service (optional: kiosk mode for Steam/Gamescope)</li> <li> <p>PAM-managed block in <code>/etc/security/time.conf</code></p> </li> <li> <p>Explicit User Monitoring:</p> </li> <li>Only users listed under <code>users:</code> in the configuration are monitored by the daemon and receive quota/curfew rules.</li> <li>An empty object (e.g. <code>kid2: {}</code>) means that defaults apply for this user.</li> <li>All other users (e.g. parents, admins, system accounts) are ignored and exempt from the rules.</li> <li> <p>This logic must be considered in all future components (enforcement, PAM, systemd, network).</p> </li> <li> <p>Modularity: Keep interfaces between components clear and simple. Policy and storage should be used as central services.</p> </li> <li>Configurability: Allow setting paths and options via ENV variables and systemd unit files.</li> <li>Security: Ensure secure permissions for IPC and database access. Backup and restore of PAM configurations.</li> <li>Fault Tolerance: Never hard lock out users due to errors in policy or database, but issue warnings and continue permissively.</li> <li> <p>Documentation: Keep the README and docstrings up to date to facilitate development for further contributors.</p> </li> <li> <p>Open Questions:</p> </li> <li>How are notifications technically triggered (guardian_agent)? DBus, socket, command?</li> <li>How are systemd timers caught up if the computer is not running at the reset time?</li> <li>How are game sessions and their enforcement/notification technically implemented?</li> <li> <p>How flexible and dynamic should PAM rules be adjusted?</p> </li> <li> <p>Explicit User Monitoring:</p> </li> <li>Only users listed under <code>users:</code> in the configuration are monitored by the daemon and receive quota/curfew rules.</li> <li>An empty object (e.g. <code>kid2: {}</code>) means that defaults apply for this user.</li> <li>All other users (e.g. parents, admins, system accounts) are ignored and exempt from the rules.</li> <li> <p>This logic must be considered in all future components (enforcement, PAM, systemd, network).</p> </li> <li> <p>Modularity: Keep interfaces between components clear and simple. Policy and storage should be used as central services.</p> </li> <li>Configurability: Allow setting paths and options via ENV variables and systemd unit files.</li> <li>Security: Ensure secure permissions for IPC and database access. Backup and restore of PAM configurations.</li> <li>Fault Tolerance: Never hard lock out users due to errors in policy or database, but issue warnings and continue permissively.</li> <li>Documentation: Keep the README and docstrings up to date to facilitate development for further contributors.</li> </ul> <p>For questions about the architecture or implementation, see the main README in the project root.</p>"},{"location":"developer/dependency_workflow/","title":"Dependency Management Workflow","text":"<p>This document outlines the process for adding, updating, or removing dependencies in Guardian projects.</p>"},{"location":"developer/dependency_workflow/#overview","title":"Overview","text":"<p>Guardian uses UV for Python package management and dependency resolution. We use lock files (<code>uv.lock</code>) to ensure deterministic builds and consistent deployments.</p>"},{"location":"developer/dependency_workflow/#adding-or-updating-dependencies","title":"Adding or Updating Dependencies","text":"<p>When adding or modifying dependencies in any of the Guardian components:</p> <ol> <li>Update the <code>pyproject.toml</code> file of the relevant component with the new/updated dependency.</li> </ol> <pre><code> cd path/to/guardian_project_root/component/\n uv add new-package\n</code></pre> <ol> <li>Run <code>uv sync</code> in the project root directory to update the lock file:</li> </ol> <pre><code>cd path/to/guardian_project_root/\nuv sync --all-packages --all-groups\n</code></pre> <ol> <li>Make sure to explicitly add the updated lock file to Git:</li> </ol> <pre><code>git add path/to/guardian_project_root/component/uv.lock\n</code></pre> <ol> <li>Commit and push your changes with a descriptive message:</li> </ol> <pre><code>git commit -m \"feat: add new-package dependency for feature X\"\ngit push\n</code></pre> <ol> <li>Deploy using the deploy_and_test.sh script:</li> </ol> <pre><code>./scripts/deploy_and_test.sh\n</code></pre>"},{"location":"developer/dependency_workflow/#important-notes","title":"Important Notes","text":"<ul> <li>Always commit the lock file: The <code>uv.lock</code> file ensures that the exact same package versions are used in all environments.</li> <li>Use <code>--frozen</code> in production: Our deployment scripts use the <code>--frozen</code> flag to install dependencies   exactly as specified in the lock file.</li> <li>Testing locally: When developing, you can use <code>uv run</code> without the <code>--frozen</code> flag for flexibility,   but always test with <code>--frozen</code> before deploying.</li> </ul>"},{"location":"developer/dependency_workflow/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues with dependencies not being available:</p> <ol> <li>Verify that the dependency is correctly added to <code>pyproject.toml</code></li> <li>Check that you've run <code>uv sync</code> and committed the updated lock file</li> <li>If the dependency is still not found, try running without the <code>--frozen</code> flag for debugging</li> </ol>"},{"location":"home/quickstart/","title":"Quickstart","text":"<p>Welcome to Guardian! This guide will help you get started with installing and configuring Guardian.</p> <p>Important: Guardian is experimental software and not ready for production use. Use at your own risk.</p>"},{"location":"home/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Linux system with systemd and D-Bus</li> <li>Python 3.10 or higher</li> <li>Root/sudo access for installation</li> <li><code>authselect</code> (for PAM configuration)</li> <li><code>notify-send</code> (for user notifications)</li> </ul>"},{"location":"home/quickstart/#installation","title":"Installation","text":""},{"location":"home/quickstart/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/familyguardian/guardian.git\ncd guardian\n</code></pre>"},{"location":"home/quickstart/#2-install-dependencies","title":"2. Install Dependencies","text":"<p>Guardian uses uv for dependency management:</p> <pre><code># Install uv if not already installed\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Install guardian-daemon\ncd guardian_daemon\nuv pip install .\n\n# Install guardianctl CLI\ncd ../guardianctl\nuv pip install .\n\n# Install guardian-agent (optional, for notifications)\ncd ../guardian_agent\nuv pip install .\n</code></pre>"},{"location":"home/quickstart/#configuration","title":"Configuration","text":""},{"location":"home/quickstart/#1-create-configuration-file","title":"1. Create Configuration File","text":"<p>Create a configuration file at <code>/etc/guardian/daemon/config.yaml</code>:</p> <pre><code># Basic Guardian Configuration\ntimezone: \"Europe/Berlin\"\ndb_path: \"/var/lib/guardian/guardian.sqlite\"\nipc_socket: \"/run/guardian-daemon.sock\"\nreset_time: \"03:00\"\n\nlogging:\n  level: INFO\n  format: plain\n  target: stdout\n\ndefaults:\n  daily_quota_minutes: 90\n  curfew:\n    weekdays: \"08:00-20:00\"\n    saturday: \"08:00-22:00\"\n    sunday: \"09:00-20:00\"\n\nusers:\n  kid1:\n    daily_quota_minutes: 60\n    curfew:\n      weekdays: \"07:30-19:30\"\n      saturday: \"08:00-21:00\"\n      sunday: \"09:00-19:00\"\n</code></pre>"},{"location":"home/quickstart/#2-create-required-directories","title":"2. Create Required Directories","text":"<pre><code>sudo mkdir -p /var/lib/guardian\nsudo mkdir -p /etc/guardian/daemon\n</code></pre>"},{"location":"home/quickstart/#3-set-up-systemd-services","title":"3. Set Up Systemd Services","text":"<pre><code># Copy systemd service files\nsudo cp systemd_units/system/guardian_daemon.service /etc/systemd/system/\nsudo cp systemd_units/user/guardian_agent.service /etc/systemd/user/\n\n# Reload systemd\nsudo systemctl daemon-reload\n\n# Enable and start the daemon\nsudo systemctl enable guardian_daemon.service\nsudo systemctl start guardian_daemon.service\n</code></pre>"},{"location":"home/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"home/quickstart/#check-daemon-status","title":"Check Daemon Status","text":"<pre><code>sudo systemctl status guardian_daemon.service\n</code></pre>"},{"location":"home/quickstart/#using-guardianctl-cli","title":"Using guardianctl CLI","text":"<p>The <code>guardianctl</code> command provides various management functions:</p> <pre><code># Check daemon connection\nguardianctl status\n\n# List managed users\nguardianctl list-kids\n\n# Get quota information for a user\nguardianctl get-quota kid1\n\n# View systemd timers\nguardianctl list-timers\n\n# View logs\nguardianctl logs\n</code></pre>"},{"location":"home/quickstart/#verify-configuration","title":"Verify Configuration","text":"<pre><code># Check configuration\nguardianctl config-check\n\n# Check socket connectivity\nguardianctl socket-check\n</code></pre>"},{"location":"home/quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"home/quickstart/#daemon-wont-start","title":"Daemon Won't Start","text":"<ol> <li>Check logs: <code>sudo journalctl -u guardian_daemon.service -n 50</code></li> <li>Verify configuration: <code>guardianctl config-check</code></li> <li>Check permissions on <code>/var/lib/guardian/</code></li> </ol>"},{"location":"home/quickstart/#user-cant-log-in","title":"User Can't Log In","text":"<ol> <li>Check PAM configuration: <code>sudo cat /etc/security/time.conf</code></li> <li>Verify user is in the <code>kids</code> group: <code>groups username</code></li> <li>Check if outside curfew hours</li> <li>Review daemon logs for enforcement actions</li> </ol>"},{"location":"home/quickstart/#cli-cant-connect","title":"CLI Can't Connect","text":"<ol> <li>Check socket exists: <code>guardianctl socket-check</code></li> <li>Verify daemon is running: <code>sudo systemctl status guardian_daemon.service</code></li> <li>Check socket permissions: <code>ls -l /run/guardian-daemon.sock</code></li> </ol>"},{"location":"home/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Read the full documentation</li> <li>Learn about implementation details</li> <li>Understand curfew configuration</li> <li>Explore Guardian Daemon API</li> </ul>"},{"location":"reference/agent/","title":"Guardian Agent","text":""},{"location":"reference/agent/#guardian_agent","title":"guardian_agent","text":"<p>Modules:</p> <ul> <li> <code>lock_events</code>           \u2013            <p>Guardian Agent: Tracks KDE screen lock/unlock events and sends them to the daemon via D-Bus IPC.</p> </li> <li> <code>logging</code>           \u2013            <p>Guardian logging setup module.</p> </li> </ul>"},{"location":"reference/agent/#guardian_agent.lock_events","title":"lock_events","text":"<p>Guardian Agent: Tracks KDE screen lock/unlock events and sends them to the daemon via D-Bus IPC.</p> <p>Classes:</p> <ul> <li> <code>LockEventReporter</code>           \u2013            </li> </ul>"},{"location":"reference/agent/#guardian_agent.lock_events.LockEventReporter","title":"LockEventReporter","text":"<pre><code>LockEventReporter(\n    session_id, username, system_bus, session_bus\n)\n</code></pre> <p>Methods:</p> <ul> <li> <code>listen_kde_locks</code>             \u2013              <p>Listen for KDE lock/unlock events via DBus and send to daemon.</p> </li> <li> <code>send_lock_event</code>             \u2013              <p>Send lock/unlock event to daemon via D-Bus IPC, with deduplication.</p> </li> </ul>"},{"location":"reference/agent/#guardian_agent.lock_events.LockEventReporter.listen_kde_locks","title":"listen_kde_locks  <code>async</code>","text":"<pre><code>listen_kde_locks()\n</code></pre> <p>Listen for KDE lock/unlock events via DBus and send to daemon.</p>"},{"location":"reference/agent/#guardian_agent.lock_events.LockEventReporter.send_lock_event","title":"send_lock_event  <code>async</code>","text":"<pre><code>send_lock_event(locked: bool)\n</code></pre> <p>Send lock/unlock event to daemon via D-Bus IPC, with deduplication. Ignores systemd-user sessions.</p>"},{"location":"reference/agent/#guardian_agent.logging","title":"logging","text":"<p>Guardian logging setup module. Configures log level, format, and target based on config.yaml/default-config.yaml.</p> <p>Functions:</p> <ul> <li> <code>load_logging_config</code>             \u2013              <p>Loads logging configuration from config.yaml or default-config.yaml.</p> </li> <li> <code>setup_logging</code>             \u2013              <p>Sets up structlog and stdlib logging according to config.</p> </li> </ul>"},{"location":"reference/agent/#guardian_agent.logging.load_logging_config","title":"load_logging_config","text":"<pre><code>load_logging_config()\n</code></pre> <p>Loads logging configuration from config.yaml or default-config.yaml. Returns dict with level, format, target from the 'logging' section.</p>"},{"location":"reference/agent/#guardian_agent.logging.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging()\n</code></pre> <p>Sets up structlog and stdlib logging according to config.</p>"},{"location":"reference/ctl/","title":"Guardian CLI Tool","text":""},{"location":"reference/ctl/#guardianctl","title":"guardianctl","text":"<p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>CLI-Tool f\u00fcr guardianctl (Typer).</p> </li> </ul>"},{"location":"reference/ctl/#guardianctl.cli","title":"cli","text":"<p>CLI-Tool f\u00fcr guardianctl (Typer).</p> <p>Functions:</p> <ul> <li> <code>create_command</code>             \u2013              <p>Dynamically create and register a command with the Typer app instance.</p> </li> <li> <code>format_command_output</code>             \u2013              <p>Format command output in a user-friendly way based on the command type.</p> </li> <li> <code>get_available_commands</code>             \u2013              <p>Query the daemon for available commands and their descriptions.</p> </li> <li> <code>ipc_call</code>             \u2013              <p>Send an IPC command to the daemon and return the response.</p> </li> <li> <code>register_diagnostic_commands</code>             \u2013              <p>Register diagnostic commands for when we can't connect to the daemon.</p> </li> <li> <code>register_dynamic_commands</code>             \u2013              <p>Register commands dynamically based on what the IPC server supports.</p> </li> </ul>"},{"location":"reference/ctl/#guardianctl.cli.create_command","title":"create_command","text":"<pre><code>create_command(\n    app_instance, cli_name, ipc_name, description, params\n)\n</code></pre> <p>Dynamically create and register a command with the Typer app instance.</p>"},{"location":"reference/ctl/#guardianctl.cli.format_command_output","title":"format_command_output","text":"<pre><code>format_command_output(command, data, param=None)\n</code></pre> <p>Format command output in a user-friendly way based on the command type.</p> <p>Parameters:</p>"},{"location":"reference/ctl/#guardianctl.cli.format_command_output(command)","title":"<code>command</code>","text":"(<code>str</code>)           \u2013            <p>The IPC command name</p>"},{"location":"reference/ctl/#guardianctl.cli.format_command_output(data)","title":"<code>data</code>","text":"(<code>dict</code>)           \u2013            <p>The parsed JSON response data</p>"},{"location":"reference/ctl/#guardianctl.cli.format_command_output(param)","title":"<code>param</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The parameter passed to the command (if any)</p>"},{"location":"reference/ctl/#guardianctl.cli.get_available_commands","title":"get_available_commands","text":"<pre><code>get_available_commands() -&gt; Dict\n</code></pre> <p>Query the daemon for available commands and their descriptions.</p>"},{"location":"reference/ctl/#guardianctl.cli.ipc_call","title":"ipc_call","text":"<pre><code>ipc_call(command, arg=None)\n</code></pre> <p>Send an IPC command to the daemon and return the response.</p>"},{"location":"reference/ctl/#guardianctl.cli.register_diagnostic_commands","title":"register_diagnostic_commands","text":"<pre><code>register_diagnostic_commands()\n</code></pre> <p>Register diagnostic commands for when we can't connect to the daemon. These commands help diagnose and troubleshoot issues with the daemon connection.</p>"},{"location":"reference/ctl/#guardianctl.cli.register_dynamic_commands","title":"register_dynamic_commands","text":"<pre><code>register_dynamic_commands()\n</code></pre> <p>Register commands dynamically based on what the IPC server supports.</p>"},{"location":"reference/daemon/","title":"Guardian Daemon","text":""},{"location":"reference/daemon/#guardian_daemon","title":"guardian_daemon","text":"<p>Modules:</p> <ul> <li> <code>config</code>           \u2013            <p>Configuration management for the Guardian Daemon.</p> </li> <li> <code>enforcer</code>           \u2013            <p>Enforcement module for guardian-daemon.</p> </li> <li> <code>ipc</code>           \u2013            <p>IPC server for admin commands of the Guardian Daemon.</p> </li> <li> <code>logging</code>           \u2013            <p>Guardian logging setup module.</p> </li> <li> <code>models</code>           \u2013            <p>SQLAlchemy models for guardian_daemon.</p> </li> <li> <code>net_client</code>           \u2013            <p>API/WebSocket hub client for guardian-daemon.</p> </li> <li> <code>policy</code>           \u2013            <p>Policy loader for guardian-daemon.</p> </li> <li> <code>sessions</code>           \u2013            <p>Session tracking for guardian-daemon.</p> </li> <li> <code>storage</code>           \u2013            <p>Central SQLAlchemy interface for guardian-daemon.</p> </li> <li> <code>systemd_manager</code>           \u2013            <p>Systemd manager for guardian-daemon.</p> </li> <li> <code>user_manager</code>           \u2013            <p>User manager for guardian-daemon.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.config","title":"config","text":"<p>Configuration management for the Guardian Daemon.</p> <p>Classes:</p> <ul> <li> <code>Config</code>           \u2013            <p>Handles loading, merging, and validating the daemon's configuration.</p> </li> <li> <code>ConfigError</code>           \u2013            <p>Custom exception for configuration errors.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.config.Config","title":"Config","text":"<pre><code>Config(config_path=None)\n</code></pre> <p>Handles loading, merging, and validating the daemon's configuration.</p> <p>Configuration Loading Priority (highest to lowest): 1. Explicitly provided path via config_path parameter 2. Environment variable GUARDIAN_DAEMON_CONFIG 3. System-wide config at /etc/guardian/daemon/config.yaml 4. Local config (development) in project directory</p> <p>The configuration system uses a two-layer approach: - Default configuration (always loaded from default-config.yaml) - User configuration (merged on top of defaults)</p> <p>This ensures that all required keys exist even if the user config is minimal or missing.</p> Example <p>config = Config(\"/etc/guardian/daemon/config.yaml\") db_path = config.get(\"db_path\") users = config[\"users\"]</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ConfigError</code>             \u2013            <p>If configuration validation fails</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get</code>             \u2013              <p>Gets a configuration value.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.config.Config(config_path)","title":"<code>config_path</code>","text":"\u2013            <p>Optional explicit path to configuration file.         If not provided, searches in priority order:         1. GUARDIAN_DAEMON_CONFIG env var         2. /etc/guardian/daemon/config.yaml         3. Local config.yaml (development)</p>"},{"location":"reference/daemon/#guardian_daemon.config.Config.get","title":"get","text":"<pre><code>get(key, default=None)\n</code></pre> <p>Gets a configuration value.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li>           \u2013            <p>The configuration value or default</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.config.Config.get(key)","title":"<code>key</code>","text":"\u2013            <p>Configuration key to retrieve</p>"},{"location":"reference/daemon/#guardian_daemon.config.Config.get(default)","title":"<code>default</code>","text":"\u2013            <p>Default value if key not found</p>"},{"location":"reference/daemon/#guardian_daemon.config.ConfigError","title":"ConfigError","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for configuration errors.</p>"},{"location":"reference/daemon/#guardian_daemon.enforcer","title":"enforcer","text":"<p>Enforcement module for guardian-daemon. Checks quota and curfew, enforces limits by terminating sessions and blocking logins.</p> <p>Classes:</p> <ul> <li> <code>Enforcer</code>           \u2013            <p>Enforcement logic for quota and curfew. Handles session termination and user notifications.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.enforcer.Enforcer","title":"Enforcer","text":"<pre><code>Enforcer(policy: Policy, tracker: SessionTracker)\n</code></pre> <p>Enforcement logic for quota and curfew. Handles session termination and user notifications.</p> <p>Methods:</p> <ul> <li> <code>enforce_user</code>             \u2013              <p>Checks quota and curfew for a user and enforces actions if necessary.</p> </li> <li> <code>handle_grace_period</code>             \u2013              <p>Handles the grace period by notifying the user every minute until time is up.</p> </li> <li> <code>notify_user</code>             \u2013              <p>Sends a desktop notification to all matching agents of the given user (via D-Bus).</p> </li> <li> <code>terminate_session</code>             \u2013              <p>Terminates all running desktop sessions of the user (via systemd loginctl).</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.enforcer.Enforcer.enforce_user","title":"enforce_user  <code>async</code>","text":"<pre><code>enforce_user(username)\n</code></pre> <p>Checks quota and curfew for a user and enforces actions if necessary.</p> <p>Uses intelligent throttling to avoid redundant enforcement checks: - Skips check if user is already in grace period - Skips check if last check was recent and time hasn't changed much</p>"},{"location":"reference/daemon/#guardian_daemon.enforcer.Enforcer.handle_grace_period","title":"handle_grace_period  <code>async</code>","text":"<pre><code>handle_grace_period(username)\n</code></pre> <p>Handles the grace period by notifying the user every minute until time is up.</p>"},{"location":"reference/daemon/#guardian_daemon.enforcer.Enforcer.notify_user","title":"notify_user  <code>async</code>","text":"<pre><code>notify_user(username, message, category='info')\n</code></pre> <p>Sends a desktop notification to all matching agents of the given user (via D-Bus). Implements a debounce mechanism to avoid sending too many similar notifications.</p>"},{"location":"reference/daemon/#guardian_daemon.enforcer.Enforcer.terminate_session","title":"terminate_session  <code>async</code>","text":"<pre><code>terminate_session(username)\n</code></pre> <p>Terminates all running desktop sessions of the user (via systemd loginctl). Only sessions with a desktop environment (not systemd-user/service) are targeted.</p>"},{"location":"reference/daemon/#guardian_daemon.ipc","title":"ipc","text":"<p>IPC server for admin commands of the Guardian Daemon.</p> <p>Classes:</p> <ul> <li> <code>GuardianIPCServer</code>           \u2013            <p>IPC server for admin commands of the Guardian Daemon.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer","title":"GuardianIPCServer","text":"<pre><code>GuardianIPCServer(\n    config, tracker: SessionTracker, policy: Policy\n)\n</code></pre> <p>IPC server for admin commands of the Guardian Daemon. Provides a socket interface for status and control commands.</p> <p>Security: Enforces request size limits and proper authentication.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>close</code>             \u2013              <p>Closes the IPC socket and removes the socket file.</p> </li> <li> <code>handle_add_user</code>             \u2013              <p>Add a new user to the database with default settings.</p> </li> <li> <code>handle_connection</code>             \u2013              <p>Handles an incoming client connection.</p> </li> <li> <code>handle_describe_commands</code>             \u2013              <p>Returns a description of all available IPC commands and their parameters as JSON.</p> </li> <li> <code>handle_get_curfew</code>             \u2013              <p>Returns the current curfew times of a kid.</p> </li> <li> <code>handle_get_quota</code>             \u2013              <p>Returns the current quota status of a kid.</p> </li> <li> <code>handle_list_kids</code>             \u2013              <p>Returns the list of all kids (users).</p> </li> <li> <code>handle_list_timers</code>             \u2013              <p>Lists all active Guardian timers.</p> </li> <li> <code>handle_reload_timers</code>             \u2013              <p>Reloads the timer configuration.</p> </li> <li> <code>handle_reset_quota</code>             \u2013              <p>Resets the daily quota for all users (deletes sessions since last reset).</p> </li> <li> <code>handle_setup_user</code>             \u2013              <p>Sets up a user with Guardian (adds to groups, creates systemd services, etc).</p> </li> <li> <code>handle_sync_users_from_config</code>             \u2013              <p>Reset user settings in the database to match the configuration file.</p> </li> <li> <code>handle_unlock_all</code>             \u2013              <p>Emergency unlock all managed user accounts.</p> </li> <li> <code>handle_unlock_user</code>             \u2013              <p>Unlock a specific user's account to allow login.</p> </li> <li> <code>handle_update_user</code>             \u2013              <p>Update a specific setting for a user.</p> </li> <li> <code>start</code>             \u2013              <p>Starts the IPC server.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer(config)","title":"<code>config</code>","text":"(<code>dict</code>)           \u2013            <p>Configuration data</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer(tracker)","title":"<code>tracker</code>","text":"(<code>SessionTracker</code>)           \u2013            <p>The main session tracker instance.</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer(policy)","title":"<code>policy</code>","text":"(<code>Policy</code>)           \u2013            <p>The main policy instance.</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Closes the IPC socket and removes the socket file.</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_add_user","title":"handle_add_user","text":"<pre><code>handle_add_user(username)\n</code></pre> <p>Add a new user to the database with default settings.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_add_user(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username to add</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_connection","title":"handle_connection  <code>async</code>","text":"<pre><code>handle_connection(reader, writer)\n</code></pre> <p>Handles an incoming client connection. Enforces authentication, request size limits, and rate limiting.</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_describe_commands","title":"handle_describe_commands","text":"<pre><code>handle_describe_commands(_)\n</code></pre> <p>Returns a description of all available IPC commands and their parameters as JSON. This is used by the CLI for automatic command discovery.</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_get_curfew","title":"handle_get_curfew","text":"<pre><code>handle_get_curfew(kid)\n</code></pre> <p>Returns the current curfew times of a kid.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_get_curfew(kid)","title":"<code>kid</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_get_quota","title":"handle_get_quota  <code>async</code>","text":"<pre><code>handle_get_quota(kid)\n</code></pre> <p>Returns the current quota status of a kid. All time values are in minutes in the returned JSON.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>          \u2013            <p>JSON string with quota information (used, limit, remaining in minutes)</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_get_quota(kid)","title":"<code>kid</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_list_kids","title":"handle_list_kids","text":"<pre><code>handle_list_kids(_)\n</code></pre> <p>Returns the list of all kids (users).</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_list_timers","title":"handle_list_timers","text":"<pre><code>handle_list_timers(_)\n</code></pre> <p>Lists all active Guardian timers.</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_reload_timers","title":"handle_reload_timers","text":"<pre><code>handle_reload_timers(_)\n</code></pre> <p>Reloads the timer configuration.</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_reset_quota","title":"handle_reset_quota  <code>async</code>","text":"<pre><code>handle_reset_quota(_)\n</code></pre> <p>Resets the daily quota for all users (deletes sessions since last reset).</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_setup_user","title":"handle_setup_user","text":"<pre><code>handle_setup_user(username)\n</code></pre> <p>Sets up a user with Guardian (adds to groups, creates systemd services, etc).</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_setup_user(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username of the user to set up</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_sync_users_from_config","title":"handle_sync_users_from_config","text":"<pre><code>handle_sync_users_from_config(_)\n</code></pre> <p>Reset user settings in the database to match the configuration file. This also imports new users from the config to the database.</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_unlock_all","title":"handle_unlock_all  <code>async</code>","text":"<pre><code>handle_unlock_all(_)\n</code></pre> <p>Emergency unlock all managed user accounts.</p> <p>Returns:</p> <ul> <li>           \u2013            <p>JSON response with count of unlocked users and details</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_unlock_user","title":"handle_unlock_user  <code>async</code>","text":"<pre><code>handle_unlock_user(username)\n</code></pre> <p>Unlock a specific user's account to allow login.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li>           \u2013            <p>JSON response with success status or error message</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_unlock_user(username)","title":"<code>username</code>","text":"\u2013            <p>Username to unlock</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_update_user","title":"handle_update_user","text":"<pre><code>handle_update_user(args)\n</code></pre> <p>Update a specific setting for a user.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.handle_update_user(args)","title":"<code>args</code>","text":"(<code>str</code>)           \u2013            <p>Format should be \"username setting_key setting_value\"</p>"},{"location":"reference/daemon/#guardian_daemon.ipc.GuardianIPCServer.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> <p>Starts the IPC server.</p>"},{"location":"reference/daemon/#guardian_daemon.logging","title":"logging","text":"<p>Guardian logging setup module. Configures log level, format, and target based on the application config.</p> <p>Functions:</p> <ul> <li> <code>get_logger</code>             \u2013              <p>Returns a configured structlog logger instance.</p> </li> <li> <code>setup_logging</code>             \u2013              <p>Sets up structlog and stdlib logging according to the provided config.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.logging.get_logger","title":"get_logger","text":"<pre><code>get_logger(name)\n</code></pre> <p>Returns a configured structlog logger instance.</p>"},{"location":"reference/daemon/#guardian_daemon.logging.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(config)\n</code></pre> <p>Sets up structlog and stdlib logging according to the provided config. This function should only be called once at application startup.</p>"},{"location":"reference/daemon/#guardian_daemon.models","title":"models","text":"<p>SQLAlchemy models for guardian_daemon.</p> <p>Key design decisions: - Session.id is an autoincrement primary key (not using logind session_id as PK) - logind_session_id is stored but is transient and can be reused by the system - Unique constraint on (username, date, start_time) to prevent duplicate sessions</p> <p>Classes:</p> <ul> <li> <code>Base</code>           \u2013            <p>Base class for all models.</p> </li> <li> <code>History</code>           \u2013            <p>Historical session summaries by user and date.</p> </li> <li> <code>Meta</code>           \u2013            <p>Metadata key-value storage.</p> </li> <li> <code>Session</code>           \u2013            <p>Represents a user session.</p> </li> <li> <code>UserSettings</code>           \u2013            <p>User settings and configuration.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.models.Base","title":"Base","text":"<p>               Bases: <code>DeclarativeBase</code></p> <p>Base class for all models.</p>"},{"location":"reference/daemon/#guardian_daemon.models.History","title":"History","text":"<p>               Bases: <code>Base</code></p> <p>Historical session summaries by user and date.</p>"},{"location":"reference/daemon/#guardian_daemon.models.Meta","title":"Meta","text":"<p>               Bases: <code>Base</code></p> <p>Metadata key-value storage.</p>"},{"location":"reference/daemon/#guardian_daemon.models.Session","title":"Session","text":"<p>               Bases: <code>Base</code></p> <p>Represents a user session.</p> <p>Note: The id is an autoincrement value, NOT the logind session ID. The logind_session_id is stored separately as it's transient and can be reused by the system for different users on different days.</p>"},{"location":"reference/daemon/#guardian_daemon.models.UserSettings","title":"UserSettings","text":"<p>               Bases: <code>Base</code></p> <p>User settings and configuration.</p>"},{"location":"reference/daemon/#guardian_daemon.net_client","title":"net_client","text":"<p>API/WebSocket hub client for guardian-daemon.</p> <p>NOTE: This module is not yet implemented. Only stub placeholder exists. The network client is planned for Phase 1 of the project roadmap.</p> <p>Planned functionality: - HTTP client for guardian-hub API - WebSocket connection for real-time updates - Policy synchronization from hub - Usage data upload to hub - Heartbeat mechanism - Offline queue for when hub is unavailable</p>"},{"location":"reference/daemon/#guardian_daemon.policy","title":"policy","text":"<p>Policy loader for guardian-daemon. Loads and validates settings from a YAML configuration file.</p> <p>Classes:</p> <ul> <li> <code>Policy</code>           \u2013            </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy","title":"Policy","text":"<pre><code>Policy(\n    config_path: Optional[str] = None,\n    db_path: Optional[str] = None,\n)\n</code></pre> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_user</code>             \u2013              <p>Adds a user to the policy with default settings.</p> </li> <li> <code>get_all_usernames</code>             \u2013              <p>Returns a list of all usernames in the policy.</p> </li> <li> <code>get_default</code>             \u2013              <p>Return a default value from the policy.</p> </li> <li> <code>get_grace_time</code>             \u2013              <p>Returns the grace time in minutes for a user.</p> </li> <li> <code>get_monitored_users</code>             \u2013              <p>Get list of all monitored users (excluding those with monitored: False).</p> </li> <li> <code>get_timezone</code>             \u2013              <p>Returns the configured timezone or the default timezone.</p> </li> <li> <code>get_user_curfew</code>             \u2013              <p>Get curfew settings for a user.</p> </li> <li> <code>get_user_policy</code>             \u2013              <p>Return the policy settings for a specific user.</p> </li> <li> <code>get_user_quota</code>             \u2013              <p>Get daily and weekly quota for a user.</p> </li> <li> <code>has_curfew</code>             \u2013              <p>Check if a user has curfew settings.</p> </li> <li> <code>has_quota</code>             \u2013              <p>Check if a user has quota settings and is not quota_exempt.</p> </li> <li> <code>reload</code>             \u2013              <p>Reload the policy configuration and synchronize with the database.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy(config_path)","title":"<code>config_path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Path to the YAML configuration file.</p>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy(db_path)","title":"<code>db_path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Path to the SQLite database.</p>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.add_user","title":"add_user","text":"<pre><code>add_user(username: str) -&gt; bool\n</code></pre> <p>Adds a user to the policy with default settings.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the user was added, False otherwise</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.add_user(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username to add</p>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.get_all_usernames","title":"get_all_usernames","text":"<pre><code>get_all_usernames() -&gt; list\n</code></pre> <p>Returns a list of all usernames in the policy.</p> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>List of usernames</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.get_default","title":"get_default","text":"<pre><code>get_default(key: str) -&gt; Any\n</code></pre> <p>Return a default value from the policy.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code> (              <code>Any</code> )          \u2013            <p>The default value or None</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.get_default(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>Name of the default key</p>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.get_grace_time","title":"get_grace_time","text":"<pre><code>get_grace_time(username: str) -&gt; int\n</code></pre> <p>Returns the grace time in minutes for a user. This is the time allowed after quota is exhausted before terminating the session.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Grace time in minutes (defaults to 5)</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.get_grace_time(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username to get grace time for</p>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.get_monitored_users","title":"get_monitored_users","text":"<pre><code>get_monitored_users() -&gt; list[str]\n</code></pre> <p>Get list of all monitored users (excluding those with monitored: False).</p>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.get_timezone","title":"get_timezone","text":"<pre><code>get_timezone() -&gt; str\n</code></pre> <p>Returns the configured timezone or the default timezone.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Timezone string</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.get_user_curfew","title":"get_user_curfew","text":"<pre><code>get_user_curfew(\n    username: str, is_weekend: bool\n) -&gt; Optional[dict[str, str]]\n</code></pre> <p>Get curfew settings for a user.</p>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.get_user_policy","title":"get_user_policy","text":"<pre><code>get_user_policy(username: str) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Return the policy settings for a specific user.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[Dict[str, Any]]</code>           \u2013            <p>dict | None: The user's settings or None if not present.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.get_user_policy(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.get_user_quota","title":"get_user_quota","text":"<pre><code>get_user_quota(username: str) -&gt; tuple[int, int]\n</code></pre> <p>Get daily and weekly quota for a user.</p>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.has_curfew","title":"has_curfew","text":"<pre><code>has_curfew(username: str) -&gt; bool\n</code></pre> <p>Check if a user has curfew settings.</p>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.has_quota","title":"has_quota","text":"<pre><code>has_quota(username: str) -&gt; bool\n</code></pre> <p>Check if a user has quota settings and is not quota_exempt.</p>"},{"location":"reference/daemon/#guardian_daemon.policy.Policy.reload","title":"reload","text":"<pre><code>reload()\n</code></pre> <p>Reload the policy configuration and synchronize with the database.</p>"},{"location":"reference/daemon/#guardian_daemon.sessions","title":"sessions","text":"<p>Session tracking for guardian-daemon. Monitors logins/logouts via systemd-logind (DBus), measures usage time and checks quota/curfew. Stores data in SQLite.</p> <p>Classes:</p> <ul> <li> <code>GuardianDaemonInterface</code>           \u2013            </li> <li> <code>SessionTracker</code>           \u2013            <p>Monitors and stores user sessions, checks quota and curfew.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_boot_id</code>             \u2013              <p>Get the system boot ID to make session IDs unique across reboots.</p> </li> <li> <code>make_unique_session_id</code>             \u2013              <p>Create a unique session ID that persists across daemon restarts but changes across reboots.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.sessions.GuardianDaemonInterface","title":"GuardianDaemonInterface","text":"<pre><code>GuardianDaemonInterface(session_tracker)\n</code></pre> <p>               Bases: <code>ServiceInterface</code></p> <p>Methods:</p> <ul> <li> <code>LockEvent</code>             \u2013              <p>Receives lock/unlock events from agents and forwards to SessionTracker.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.sessions.GuardianDaemonInterface.LockEvent","title":"LockEvent  <code>async</code>","text":"<pre><code>LockEvent(\n    session_id: s, username: s, locked: b, timestamp: d\n)\n</code></pre> <p>Receives lock/unlock events from agents and forwards to SessionTracker.</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker","title":"SessionTracker","text":"<pre><code>SessionTracker(\n    policy: Policy, config: dict, user_manager: UserManager\n)\n</code></pre> <p>Monitors and stores user sessions, checks quota and curfew. Connects to systemd-logind via DBus.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>check_curfew</code>             \u2013              <p>Check if a user is allowed to log in at the current time based on curfew settings.</p> </li> <li> <code>check_daily_reset_on_startup</code>             \u2013              <p>Check if we need to perform a daily reset on daemon startup or system wake.</p> </li> <li> <code>check_quota</code>             \u2013              <p>Check if a user is within their quota limits.</p> </li> <li> <code>check_usage_summarize</code>             \u2013              <p>Check if we need to summarize usage and add to history.</p> </li> <li> <code>discover_agent_names_for_user</code>             \u2013              <p>Scans the D-Bus for all available agent service names for a given user</p> </li> <li> <code>get_active_users</code>             \u2013              <p>Return a list of currently active usernames.</p> </li> <li> <code>get_agent_names_for_user</code>             \u2013              <p>Return the cached list of D-Bus agent names for a user, or empty list if not found.</p> </li> <li> <code>get_agent_paths_for_user</code>             \u2013              <p>Returns a list of D-Bus object paths for agents belonging to the given user.</p> </li> <li> <code>get_remaining_time</code>             \u2013              <p>Returns the remaining allowed time for the given user today.</p> </li> <li> <code>get_total_time</code>             \u2013              <p>Returns the total allowed time (in minutes) for the given user today.</p> </li> <li> <code>get_user_sessions</code>             \u2013              <p>Returns a list of active session details for the given user.</p> </li> <li> <code>handle_login</code>             \u2013              <p>Register a new session on login for child accounts.</p> </li> <li> <code>handle_logout</code>             \u2013              <p>End a session on logout and save it in the database for child accounts.</p> </li> <li> <code>pause_user_time</code>             \u2013              <p>Pause time tracking for a user when a lock event is received for an unknown session.</p> </li> <li> <code>perform_daily_reset</code>             \u2013              <p>Perform daily reset: summarize sessions, create history entries,</p> </li> <li> <code>periodic_session_update</code>             \u2013              <p>Periodically update all active sessions in the database with current duration.</p> </li> <li> <code>receive_lock_event</code>             \u2013              <p>Called via D-Bus/IPC from agent to record lock/unlock events for a session.</p> </li> <li> <code>refresh_agent_name_mapping</code>             \u2013              <p>Refresh the mapping of usernames to their current D-Bus agent names using discover_agent_names_for_user().</p> </li> <li> <code>run</code>             \u2013              <p>Start session tracking, connect to systemd-logind via DBus, and listen for KDE lock events.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker(policy)","title":"<code>policy</code>","text":"(<code>Policy</code>)           \u2013            <p>Policy instance</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker(config)","title":"<code>config</code>","text":"(<code>dict</code>)           \u2013            <p>Parsed configuration</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker(user_manager)","title":"<code>user_manager</code>","text":"(<code>UserManager</code>)           \u2013            <p>User manager instance for setting up user sessions</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.check_curfew","title":"check_curfew  <code>async</code>","text":"<pre><code>check_curfew(\n    username: str, current_time, is_weekend: bool\n) -&gt; bool\n</code></pre> <p>Check if a user is allowed to log in at the current time based on curfew settings.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if allowed, False if curfew is in effect</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.check_curfew(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.check_curfew(current_time)","title":"<code>current_time</code>","text":"\u2013            <p>Current time to check (datetime.time)</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.check_curfew(is_weekend)","title":"<code>is_weekend</code>","text":"(<code>bool</code>)           \u2013            <p>Whether it's a weekend day</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.check_daily_reset_on_startup","title":"check_daily_reset_on_startup  <code>async</code>","text":"<pre><code>check_daily_reset_on_startup()\n</code></pre> <p>Check if we need to perform a daily reset on daemon startup or system wake. This is based on the date comparison between today and the last reset date.</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.check_quota","title":"check_quota  <code>async</code>","text":"<pre><code>check_quota(username: str) -&gt; bool\n</code></pre> <p>Check if a user is within their quota limits.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if within quota, False if exceeded</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.check_quota(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.check_usage_summarize","title":"check_usage_summarize  <code>async</code>","text":"<pre><code>check_usage_summarize(\n    username, used_time, quota_reached=False\n)\n</code></pre> <p>Check if we need to summarize usage and add to history. This should be called when: 1. The user reaches their daily quota 2. The user logs out and it's their last session of the day</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.check_usage_summarize(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username to check</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.check_usage_summarize(used_time)","title":"<code>used_time</code>","text":"(<code>float</code>)           \u2013            <p>Used time in seconds</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.check_usage_summarize(quota_reached)","title":"<code>quota_reached</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the quota was reached</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.discover_agent_names_for_user","title":"discover_agent_names_for_user  <code>async</code>","text":"<pre><code>discover_agent_names_for_user(username: str)\n</code></pre> <p>Scans the D-Bus for all available agent service names for a given user and updates the internal map.</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.get_active_users","title":"get_active_users  <code>async</code>","text":"<pre><code>get_active_users() -&gt; list\n</code></pre> <p>Return a list of currently active usernames.</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.get_agent_names_for_user","title":"get_agent_names_for_user","text":"<pre><code>get_agent_names_for_user(username: str) -&gt; list\n</code></pre> <p>Return the cached list of D-Bus agent names for a user, or empty list if not found. Converts from set to list if necessary.</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.get_agent_paths_for_user","title":"get_agent_paths_for_user","text":"<pre><code>get_agent_paths_for_user(username: str)\n</code></pre> <p>Returns a list of D-Bus object paths for agents belonging to the given user. This should be tracked in active_sessions as 'agent_path' if available, otherwise default to /org/guardian/Agent or numbered agents.</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.get_remaining_time","title":"get_remaining_time  <code>async</code>","text":"<pre><code>get_remaining_time(username: str) -&gt; float\n</code></pre> <p>Returns the remaining allowed time for the given user today. All calculations use minutes as the base unit to match the API contract.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Remaining screen time in minutes</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.get_total_time","title":"get_total_time  <code>async</code>","text":"<pre><code>get_total_time(username: str) -&gt; float\n</code></pre> <p>Returns the total allowed time (in minutes) for the given user today.</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>Total allowed screen time in minutes</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.get_user_sessions","title":"get_user_sessions","text":"<pre><code>get_user_sessions(username: str)\n</code></pre> <p>Returns a list of active session details for the given user. Each item is a dict with session_id, service, desktop, start_time, etc.</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.handle_login","title":"handle_login  <code>async</code>","text":"<pre><code>handle_login(session_id, uid, username, props)\n</code></pre> <p>Register a new session on login for child accounts. Skips systemd-user sessions. Also ensure user account is set up: PAM time rules, systemd user service, and agent.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.handle_login(session_id)","title":"<code>session_id</code>","text":"(<code>str</code>)           \u2013            <p>Session ID</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.handle_login(uid)","title":"<code>uid</code>","text":"(<code>int</code>)           \u2013            <p>User ID</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.handle_login(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.handle_logout","title":"handle_logout  <code>async</code>","text":"<pre><code>handle_logout(session_id)\n</code></pre> <p>End a session on logout and save it in the database for child accounts.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.handle_logout(session_id)","title":"<code>session_id</code>","text":"(<code>str</code>)           \u2013            <p>Logind session ID (will be mapped to unique session ID)</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.pause_user_time","title":"pause_user_time","text":"<pre><code>pause_user_time(username, timestamp)\n</code></pre> <p>Pause time tracking for a user when a lock event is received for an unknown session.</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.perform_daily_reset","title":"perform_daily_reset  <code>async</code>","text":"<pre><code>perform_daily_reset(force=False)\n</code></pre> <p>Perform daily reset: summarize sessions, create history entries, clean up sessions table, and reset quotas.</p> <p>This should be called when: 1. The system is first booted/unlocked for the day (normal reset) 2. The daily quota is reached 3. The configured reset_time is reached 4. Manually via reset-quota command (force=True)</p> <p>When force=True, resets today's quota to zero by archiving current sessions.</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.periodic_session_update","title":"periodic_session_update  <code>async</code>","text":"<pre><code>periodic_session_update(interval: int = 60)\n</code></pre> <p>Periodically update all active sessions in the database with current duration. This is critical for preserving session time across daemon restarts. Includes robust D-Bus connection handling with automatic reconnection.</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.receive_lock_event","title":"receive_lock_event  <code>async</code>","text":"<pre><code>receive_lock_event(\n    session_id: str,\n    username: str,\n    locked: bool,\n    timestamp: float,\n)\n</code></pre> <p>Called via D-Bus/IPC from agent to record lock/unlock events for a session. Also updates session progress in the database.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.receive_lock_event(session_id)","title":"<code>session_id</code>","text":"(<code>str</code>)           \u2013            <p>Logind session ID from the agent (will be mapped to unique ID)</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.refresh_agent_name_mapping","title":"refresh_agent_name_mapping  <code>async</code>","text":"<pre><code>refresh_agent_name_mapping()\n</code></pre> <p>Refresh the mapping of usernames to their current D-Bus agent names using discover_agent_names_for_user(). Stores the mapping in self.agent_name_map: {username: {dbus_name, ...}}</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.SessionTracker.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>Start session tracking, connect to systemd-logind via DBus, and listen for KDE lock events. Also checks for already logged-in child sessions on startup. Periodically updates session progress in the database.</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.get_boot_id","title":"get_boot_id","text":"<pre><code>get_boot_id() -&gt; str\n</code></pre> <p>Get the system boot ID to make session IDs unique across reboots.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Boot ID or empty string if not available</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.sessions.make_unique_session_id","title":"make_unique_session_id","text":"<pre><code>make_unique_session_id(\n    logind_session_id: str, boot_id: str = None\n) -&gt; str\n</code></pre> <p>Create a unique session ID that persists across daemon restarts but changes across reboots.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Unique session ID in format \"bootid_sessionid\" or just sessionid if no boot_id</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.sessions.make_unique_session_id(logind_session_id)","title":"<code>logind_session_id</code>","text":"(<code>str</code>)           \u2013            <p>The session ID from logind (e.g., \"4\", \"5\")</p>"},{"location":"reference/daemon/#guardian_daemon.sessions.make_unique_session_id(boot_id)","title":"<code>boot_id</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Optional boot ID (will fetch if not provided)</p>"},{"location":"reference/daemon/#guardian_daemon.storage","title":"storage","text":"<p>Central SQLAlchemy interface for guardian-daemon. Provides functions for session handling using SQLAlchemy ORM.</p> <p>Classes:</p> <ul> <li> <code>Storage</code>           \u2013            <p>Central SQLAlchemy interface for session and settings storage in Guardian Daemon.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage","title":"Storage","text":"<pre><code>Storage(db_path: str)\n</code></pre> <p>Central SQLAlchemy interface for session and settings storage in Guardian Daemon.</p> <p>Key design changes: - Uses SQLAlchemy ORM instead of raw SQL - Session.id is autoincrement (not using logind session_id as primary key) - logind_session_id is stored separately as it's transient - Date field tracks which day the session belongs to</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_session</code>             \u2013              <p>Adds a new session to the database.</p> </li> <li> <code>add_session_time</code>             \u2013              <p>Add a usage time entry for a user.</p> </li> <li> <code>clean_old_sessions</code>             \u2013              <p>Remove old session records for a user after they've been summarized to history.</p> </li> <li> <code>cleanup_stale_sessions</code>             \u2013              <p>Remove sessions older than the specified age.</p> </li> <li> <code>close</code>             \u2013              <p>Close the database connection.</p> </li> <li> <code>delete_sessions_since</code>             \u2013              <p>Delete all sessions from the database since the given timestamp.</p> </li> <li> <code>end_session</code>             \u2013              <p>End a session for a user.</p> </li> <li> <code>get_active_session</code>             \u2013              <p>Get an active session for a user.</p> </li> <li> <code>get_all_active_sessions</code>             \u2013              <p>Get all currently active sessions.</p> </li> <li> <code>get_all_usernames</code>             \u2013              <p>Return all usernames (except 'default') from the database.</p> </li> <li> <code>get_daily_usage</code>             \u2013              <p>Get total usage time for a user on a given date.</p> </li> <li> <code>get_history</code>             \u2013              <p>Retrieve history entries for a user within a date range.</p> </li> <li> <code>get_last_reset_date</code>             \u2013              <p>Retrieve the last daily reset date from the database.</p> </li> <li> <code>get_last_reset_timestamp</code>             \u2013              <p>Retrieve the last daily reset timestamp from the database.</p> </li> <li> <code>get_open_sessions</code>             \u2013              <p>Get all currently open sessions from the database.</p> </li> <li> <code>get_sessions_count_since</code>             \u2013              <p>Get count of sessions since a given timestamp.</p> </li> <li> <code>get_sessions_for_user</code>             \u2013              <p>Retrieve all sessions for a user, optionally since a specific time.</p> </li> <li> <code>get_usage_in_date_range</code>             \u2013              <p>Get total usage time for a user between two dates.</p> </li> <li> <code>get_user_settings</code>             \u2013              <p>Retrieve user settings from the database for the given username.</p> </li> <li> <code>get_weekly_usage</code>             \u2013              <p>Get total usage time for a user in the week containing the given date.</p> </li> <li> <code>logind_to_epoch</code>             \u2013              <p>Convert logind timestamp (microseconds since boot) to EPOCH timestamp.</p> </li> <li> <code>save_history_entry</code>             \u2013              <p>Save a history entry from a session summary.</p> </li> <li> <code>set_last_reset_date</code>             \u2013              <p>Store the last daily reset date in the database.</p> </li> <li> <code>set_last_reset_timestamp</code>             \u2013              <p>Store the last daily reset timestamp in the database.</p> </li> <li> <code>set_user_settings</code>             \u2013              <p>Store user settings in the database for the given username.</p> </li> <li> <code>summarize_user_sessions</code>             \u2013              <p>Summarize all sessions for a user on a given date and create a history entry.</p> </li> <li> <code>sync_config_to_db</code>             \u2013              <p>Synchronize configuration data to the database.</p> </li> <li> <code>update_session_logout</code>             \u2013              <p>Update session entry with logout time and duration.</p> </li> <li> <code>update_session_progress</code>             \u2013              <p>Periodically update session entry with current duration (while session is active).</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage(db_path)","title":"<code>db_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to SQLite database.</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session","title":"add_session  <code>async</code>","text":"<pre><code>add_session(\n    session_id: str,\n    username: str,\n    uid: int,\n    start_time: float,\n    end_time: float,\n    duration_seconds: float,\n    desktop: Optional[str] = None,\n    service: Optional[str] = None,\n)\n</code></pre> <p>Adds a new session to the database.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session(session_id)","title":"<code>session_id</code>","text":"(<code>str</code>)           \u2013            <p>Logind session ID (transient identifier)</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session(uid)","title":"<code>uid</code>","text":"(<code>int</code>)           \u2013            <p>User ID</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session(start_time)","title":"<code>start_time</code>","text":"(<code>float</code>)           \u2013            <p>Start time (EPOCH)</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session(end_time)","title":"<code>end_time</code>","text":"(<code>float</code>)           \u2013            <p>End time (EPOCH, 0 if still active)</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session(duration_seconds)","title":"<code>duration_seconds</code>","text":"(<code>float</code>)           \u2013            <p>Session duration in seconds</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session(desktop)","title":"<code>desktop</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Desktop environment</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session(service)","title":"<code>service</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Service (e.g. sddm)</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session_time","title":"add_session_time  <code>async</code>","text":"<pre><code>add_session_time(\n    username: str, start_time: datetime, end_time: datetime\n)\n</code></pre> <p>Add a usage time entry for a user.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session_time(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session_time(start_time)","title":"<code>start_time</code>","text":"(<code>datetime</code>)           \u2013            <p>Start time</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.add_session_time(end_time)","title":"<code>end_time</code>","text":"(<code>datetime</code>)           \u2013            <p>End time</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.clean_old_sessions","title":"clean_old_sessions","text":"<pre><code>clean_old_sessions(username: str, before_date: str = None)\n</code></pre> <p>Remove old session records for a user after they've been summarized to history.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.clean_old_sessions(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username to clean sessions for</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.clean_old_sessions(before_date)","title":"<code>before_date</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Remove sessions before this date (YYYY-MM-DD)                          If not provided, removes all sessions</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.cleanup_stale_sessions","title":"cleanup_stale_sessions  <code>async</code>","text":"<pre><code>cleanup_stale_sessions(max_age_hours: int)\n</code></pre> <p>Remove sessions older than the specified age.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.cleanup_stale_sessions(max_age_hours)","title":"<code>max_age_hours</code>","text":"(<code>int</code>)           \u2013            <p>Maximum age in hours to keep sessions</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the database connection.</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.delete_sessions_since","title":"delete_sessions_since","text":"<pre><code>delete_sessions_since(since: float)\n</code></pre> <p>Delete all sessions from the database since the given timestamp.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.delete_sessions_since(since)","title":"<code>since</code>","text":"(<code>float</code>)           \u2013            <p>Start timestamp (Unix timestamp)</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.end_session","title":"end_session  <code>async</code>","text":"<pre><code>end_session(\n    username: str, session_id: str, end_time: datetime\n)\n</code></pre> <p>End a session for a user.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.end_session(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.end_session(session_id)","title":"<code>session_id</code>","text":"(<code>str</code>)           \u2013            <p>Logind session ID</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.end_session(end_time)","title":"<code>end_time</code>","text":"(<code>datetime</code>)           \u2013            <p>End time</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_active_session","title":"get_active_session  <code>async</code>","text":"<pre><code>get_active_session(username: str, session_id: str)\n</code></pre> <p>Get an active session for a user.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple</code>          \u2013            <p>Session data or None if not found</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_active_session(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_active_session(session_id)","title":"<code>session_id</code>","text":"(<code>str</code>)           \u2013            <p>Logind session ID</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_all_active_sessions","title":"get_all_active_sessions  <code>async</code>","text":"<pre><code>get_all_active_sessions()\n</code></pre> <p>Get all currently active sessions.</p> <p>Returns:</p> <ul> <li> <code>list</code>          \u2013            <p>List of active sessions</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_all_usernames","title":"get_all_usernames","text":"<pre><code>get_all_usernames() -&gt; list\n</code></pre> <p>Return all usernames (except 'default') from the database.</p> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>List of usernames</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_daily_usage","title":"get_daily_usage  <code>async</code>","text":"<pre><code>get_daily_usage(username: str, date: date)\n</code></pre> <p>Get total usage time for a user on a given date.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>          \u2013            <p>Total usage time in seconds</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_daily_usage(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_daily_usage(date)","title":"<code>date</code>","text":"(<code>date</code>)           \u2013            <p>Date to check</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_history","title":"get_history","text":"<pre><code>get_history(\n    username: str,\n    start_date: str = None,\n    end_date: str = None,\n)\n</code></pre> <p>Retrieve history entries for a user within a date range.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>          \u2013            <p>List of history entries as dictionaries</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_history(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username to get history for</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_history(start_date)","title":"<code>start_date</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Start date in YYYY-MM-DD format</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_history(end_date)","title":"<code>end_date</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>End date in YYYY-MM-DD format</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_last_reset_date","title":"get_last_reset_date","text":"<pre><code>get_last_reset_date() -&gt; str\n</code></pre> <p>Retrieve the last daily reset date from the database.</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Date in YYYY-MM-DD format</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_last_reset_timestamp","title":"get_last_reset_timestamp","text":"<pre><code>get_last_reset_timestamp() -&gt; Optional[float]\n</code></pre> <p>Retrieve the last daily reset timestamp from the database.</p> <p>Returns:</p> <ul> <li> <code>Optional[float]</code>           \u2013            <p>float | None: EPOCH timestamp of last reset or None</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_open_sessions","title":"get_open_sessions","text":"<pre><code>get_open_sessions() -&gt; list\n</code></pre> <p>Get all currently open sessions from the database.</p> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>List of tuples (logind_session_id, username, uid, start_time, duration, desktop, service)</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_sessions_count_since","title":"get_sessions_count_since","text":"<pre><code>get_sessions_count_since(timestamp: float) -&gt; int\n</code></pre> <p>Get count of sessions since a given timestamp.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Count of sessions</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_sessions_count_since(timestamp)","title":"<code>timestamp</code>","text":"(<code>float</code>)           \u2013            <p>Unix timestamp</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_sessions_for_user","title":"get_sessions_for_user","text":"<pre><code>get_sessions_for_user(\n    username: str, since: Optional[float] = None\n) -&gt; list\n</code></pre> <p>Retrieve all sessions for a user, optionally since a specific time.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>List of sessions as tuples</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_sessions_for_user(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_sessions_for_user(since)","title":"<code>since</code>","text":"(<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Start time (Unix timestamp)</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_usage_in_date_range","title":"get_usage_in_date_range  <code>async</code>","text":"<pre><code>get_usage_in_date_range(\n    username: str, start_date: datetime, end_date: datetime\n)\n</code></pre> <p>Get total usage time for a user between two dates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>          \u2013            <p>Total usage time in seconds</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_usage_in_date_range(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_usage_in_date_range(start_date)","title":"<code>start_date</code>","text":"(<code>datetime</code>)           \u2013            <p>Start date</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_usage_in_date_range(end_date)","title":"<code>end_date</code>","text":"(<code>datetime</code>)           \u2013            <p>End date</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_user_settings","title":"get_user_settings","text":"<pre><code>get_user_settings(username: str) -&gt; Optional[dict]\n</code></pre> <p>Retrieve user settings from the database for the given username.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Optional[dict]</code>           \u2013            <p>dict | None: User settings or None</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_user_settings(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_weekly_usage","title":"get_weekly_usage  <code>async</code>","text":"<pre><code>get_weekly_usage(username: str, date: date)\n</code></pre> <p>Get total usage time for a user in the week containing the given date.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>          \u2013            <p>Total usage time in seconds</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_weekly_usage(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.get_weekly_usage(date)","title":"<code>date</code>","text":"(<code>date</code>)           \u2013            <p>Date within the week to check</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.logind_to_epoch","title":"logind_to_epoch  <code>staticmethod</code>","text":"<pre><code>logind_to_epoch(logind_timestamp: int) -&gt; float\n</code></pre> <p>Convert logind timestamp (microseconds since boot) to EPOCH timestamp.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>float</code> )          \u2013            <p>EPOCH timestamp</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.logind_to_epoch(logind_timestamp)","title":"<code>logind_timestamp</code>","text":"(<code>int</code>)           \u2013            <p>Microseconds since boot</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.save_history_entry","title":"save_history_entry","text":"<pre><code>save_history_entry(summary: dict)\n</code></pre> <p>Save a history entry from a session summary.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.save_history_entry(summary)","title":"<code>summary</code>","text":"(<code>dict</code>)           \u2013            <p>Session summary data</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.set_last_reset_date","title":"set_last_reset_date","text":"<pre><code>set_last_reset_date(date_str: str)\n</code></pre> <p>Store the last daily reset date in the database.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.set_last_reset_date(date_str)","title":"<code>date_str</code>","text":"(<code>str</code>)           \u2013            <p>Date in YYYY-MM-DD format</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.set_last_reset_timestamp","title":"set_last_reset_timestamp","text":"<pre><code>set_last_reset_timestamp(ts: float)\n</code></pre> <p>Store the last daily reset timestamp in the database.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.set_last_reset_timestamp(ts)","title":"<code>ts</code>","text":"(<code>float</code>)           \u2013            <p>EPOCH timestamp</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.set_user_settings","title":"set_user_settings","text":"<pre><code>set_user_settings(username: str, settings: dict)\n</code></pre> <p>Store user settings in the database for the given username.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.set_user_settings(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.set_user_settings(settings)","title":"<code>settings</code>","text":"(<code>dict</code>)           \u2013            <p>Settings dictionary</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.summarize_user_sessions","title":"summarize_user_sessions","text":"<pre><code>summarize_user_sessions(username: str, date: str = None)\n</code></pre> <p>Summarize all sessions for a user on a given date and create a history entry. If date is not provided, summarize sessions from the most recent day.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>          \u2013            <p>Summary of session data</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.summarize_user_sessions(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>Username to summarize sessions for</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.summarize_user_sessions(date)","title":"<code>date</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Date in YYYY-MM-DD format, defaults to today</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.sync_config_to_db","title":"sync_config_to_db","text":"<pre><code>sync_config_to_db(config: dict)\n</code></pre> <p>Synchronize configuration data to the database. Merges user settings with defaults to ensure complete configuration.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.sync_config_to_db(config)","title":"<code>config</code>","text":"(<code>dict</code>)           \u2013            <p>Configuration data</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.update_session_logout","title":"update_session_logout","text":"<pre><code>update_session_logout(\n    session_id: str,\n    end_time: float,\n    duration_seconds: float,\n)\n</code></pre> <p>Update session entry with logout time and duration.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.update_session_logout(session_id)","title":"<code>session_id</code>","text":"(<code>str</code>)           \u2013            <p>Logind session ID to update</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.update_session_logout(end_time)","title":"<code>end_time</code>","text":"(<code>float</code>)           \u2013            <p>End time in EPOCH seconds</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.update_session_logout(duration_seconds)","title":"<code>duration_seconds</code>","text":"(<code>float</code>)           \u2013            <p>Session duration in seconds</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.update_session_progress","title":"update_session_progress","text":"<pre><code>update_session_progress(\n    session_id: str, duration_seconds: float\n)\n</code></pre> <p>Periodically update session entry with current duration (while session is active). This is critical for preserving session time across daemon restarts.</p> <p>Parameters:</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.update_session_progress(session_id)","title":"<code>session_id</code>","text":"(<code>str</code>)           \u2013            <p>The logind session ID to update</p>"},{"location":"reference/daemon/#guardian_daemon.storage.Storage.update_session_progress(duration_seconds)","title":"<code>duration_seconds</code>","text":"(<code>float</code>)           \u2013            <p>Duration in seconds</p>"},{"location":"reference/daemon/#guardian_daemon.systemd_manager","title":"systemd_manager","text":"<p>Systemd manager for guardian-daemon. Creates and manages systemd timers/units for daily reset and curfew.</p> <p>Classes:</p> <ul> <li> <code>SystemdManager</code>           \u2013            <p>Manages systemd timers and units for daily reset and curfew enforcement.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.systemd_manager.SystemdManager","title":"SystemdManager","text":"<pre><code>SystemdManager()\n</code></pre> <p>Manages systemd timers and units for daily reset and curfew enforcement.</p> <p>Methods:</p> <ul> <li> <code>create_curfew_timer</code>             \u2013              <p>Create a systemd timer and service unit for curfew enforcement.</p> </li> <li> <code>create_daily_reset_timer</code>             \u2013              <p>Create a systemd timer and corresponding service unit for the daily quota reset.</p> </li> <li> <code>reload_systemd</code>             \u2013              <p>Reload systemd units to apply changes.</p> </li> <li> <code>remove_timer_and_service</code>             \u2013              <p>Remove a systemd timer and service unit by name.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.systemd_manager.SystemdManager.create_curfew_timer","title":"create_curfew_timer","text":"<pre><code>create_curfew_timer(start_time='22:00', end_time='06:00')\n</code></pre> <p>Create a systemd timer and service unit for curfew enforcement.</p>"},{"location":"reference/daemon/#guardian_daemon.systemd_manager.SystemdManager.create_daily_reset_timer","title":"create_daily_reset_timer","text":"<pre><code>create_daily_reset_timer(reset_time='03:00')\n</code></pre> <p>Create a systemd timer and corresponding service unit for the daily quota reset.</p>"},{"location":"reference/daemon/#guardian_daemon.systemd_manager.SystemdManager.reload_systemd","title":"reload_systemd  <code>async</code>","text":"<pre><code>reload_systemd()\n</code></pre> <p>Reload systemd units to apply changes.</p>"},{"location":"reference/daemon/#guardian_daemon.systemd_manager.SystemdManager.remove_timer_and_service","title":"remove_timer_and_service","text":"<pre><code>remove_timer_and_service(timer_name)\n</code></pre> <p>Remove a systemd timer and service unit by name.</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager","title":"user_manager","text":"<p>User manager for guardian-daemon. Manages login time windows for children via /etc/security/time.conf and handles user-specific systemd services.</p> <p>Classes:</p> <ul> <li> <code>SetupError</code>           \u2013            <p>Exception raised when critical setup operations fail.</p> </li> <li> <code>UserManager</code>           \u2013            <p>Manages user-specific configurations, PAM time rules, and systemd services.</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.user_manager.SetupError","title":"SetupError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when critical setup operations fail.</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager","title":"UserManager","text":"<pre><code>UserManager(\n    policy: Policy = None, tracker: SessionTracker = None\n)\n</code></pre> <p>Manages user-specific configurations, PAM time rules, and systemd services.</p> <p>This class is responsible for: - Managing the 'kids' group and user memberships - Writing and maintaining PAM time.conf rules for curfews - Setting up user-specific systemd services (guardian-agent) - Configuring D-Bus policies for agent communication - Ensuring PAM modules are properly configured</p> <p>The UserManager works closely with the Policy class to enforce time-based access controls and user quotas.</p> <p>Security: All methods that accept usernames validate them against path traversal and use canonical system paths via pwd.getpwnam().</p> <p>Parameters:</p> Note <p>The tracker can be set later using set_tracker() to avoid circular dependencies during initialization.</p> <p>Methods:</p> <ul> <li> <code>check_if_locked</code>             \u2013              <p>Check if a user account is currently locked by examining password status.</p> </li> <li> <code>ensure_kids_group</code>             \u2013              <p>Ensure the 'kids' group exists and all managed users are members of it.</p> </li> <li> <code>ensure_pam_time_module</code>             \u2013              <p>Ensures pam_time.so is active using two complementary approaches:</p> </li> <li> <code>ensure_systemd_user_service</code>             \u2013              <p>Ensure that systemd user services are set up for the given user without enabling lingering.</p> </li> <li> <code>lock_user_account</code>             \u2013              <p>Temporarily lock a user account to prevent login.</p> </li> <li> <code>remove_time_rules</code>             \u2013              <p>Remove time rules set by guardian-daemon from /etc/security/time.conf.</p> </li> <li> <code>set_tracker</code>             \u2013              <p>Set the session tracker after initialization to resolve circular dependencies.</p> </li> <li> <code>setup_dbus_policy</code>             \u2013              <p>Creates /etc/dbus-1/system.d/guardian.conf to allow managed users access to org.guardian.Daemon.</p> </li> <li> <code>setup_user_login</code>             \u2013              <p>Comprehensive setup for a user upon login.</p> </li> <li> <code>setup_user_service</code>             \u2013              <p>Sets up the guardian_agent.service for the given user's systemd.</p> </li> <li> <code>sync_account_locks</code>             \u2013              <p>Synchronize user account locks with their current quota status.</p> </li> <li> <code>unlock_all_managed_users</code>             \u2013              <p>Emergency function to unlock all managed user accounts.</p> </li> <li> <code>unlock_user_account</code>             \u2013              <p>Unlock a previously locked user account.</p> </li> <li> <code>update_policy</code>             \u2013              <p>Update the policy instance and re-evaluate rules.</p> </li> <li> <code>user_exists</code>             \u2013              <p>Check if a user exists on the system.</p> </li> <li> <code>validate_username</code>             \u2013              <p>Validate username format to prevent path traversal and injection attacks.</p> </li> <li> <code>write_time_rules</code>             \u2013              <p>Updates the time rules for all children according to the policy in /etc/security/time.conf,</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager(policy)","title":"<code>policy</code>","text":"(<code>Policy</code>, default:                   <code>None</code> )           \u2013            <p>The Policy instance containing user rules and configurations</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager(tracker)","title":"<code>tracker</code>","text":"(<code>SessionTracker</code>, default:                   <code>None</code> )           \u2013            <p>The SessionTracker instance (optional, can be set later)</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.check_if_locked","title":"check_if_locked","text":"<pre><code>check_if_locked(username: str) -&gt; bool\n</code></pre> <p>Check if a user account is currently locked by examining password status.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if account is locked, False otherwise</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.check_if_locked(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>The username to check</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.ensure_kids_group","title":"ensure_kids_group","text":"<pre><code>ensure_kids_group()\n</code></pre> <p>Ensure the 'kids' group exists and all managed users are members of it. Also ensures all managed users are in the 'users' group to access agent files.</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.ensure_pam_time_module","title":"ensure_pam_time_module","text":"<pre><code>ensure_pam_time_module()\n</code></pre> <p>Ensures pam_time.so is active using two complementary approaches:</p> <ol> <li> <p>Creates a custom authselect profile with pam_time.so in the system-auth    stack (applies to all PAM services that include system-auth)</p> </li> <li> <p>Directly modifies /etc/pam.d/sddm to explicitly include pam_time.so    before the system-account include (ensuring SDDM enforces time restrictions    even if authselect updates the system files)</p> </li> </ol> <p>This dual approach ensures maximum compatibility and resilience against system updates or configuration changes.</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.ensure_systemd_user_service","title":"ensure_systemd_user_service","text":"<pre><code>ensure_systemd_user_service(username)\n</code></pre> <p>Ensure that systemd user services are set up for the given user without enabling lingering. Only starts the service if the user is actively logged in with a session.</p> <p>Security: Validates username and uses pwd.getpwnam() to prevent path traversal.</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.lock_user_account","title":"lock_user_account","text":"<pre><code>lock_user_account(username: str) -&gt; bool\n</code></pre> <p>Temporarily lock a user account to prevent login. Uses usermod -L to disable password authentication.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if successful, False otherwise</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.lock_user_account(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>The username to lock</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.remove_time_rules","title":"remove_time_rules","text":"<pre><code>remove_time_rules()\n</code></pre> <p>Remove time rules set by guardian-daemon from /etc/security/time.conf.</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.set_tracker","title":"set_tracker","text":"<pre><code>set_tracker(tracker: SessionTracker)\n</code></pre> <p>Set the session tracker after initialization to resolve circular dependencies.</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.setup_dbus_policy","title":"setup_dbus_policy","text":"<pre><code>setup_dbus_policy()\n</code></pre> <p>Creates /etc/dbus-1/system.d/guardian.conf to allow managed users access to org.guardian.Daemon. Both 'kids' and 'users' groups are given permissions to support transition periods.</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.setup_user_login","title":"setup_user_login","text":"<pre><code>setup_user_login(username: str) -&gt; bool\n</code></pre> <p>Comprehensive setup for a user upon login. Ensures group membership, PAM rules, and systemd service are correctly configured.</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.setup_user_service","title":"setup_user_service","text":"<pre><code>setup_user_service(username: str)\n</code></pre> <p>Sets up the guardian_agent.service for the given user's systemd. Updates the service file if its checksum has changed. Ensures correct directory structure and permissions.</p> <p>Security: Validates username and uses pwd.getpwnam() to prevent path traversal.</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.sync_account_locks","title":"sync_account_locks  <code>async</code>","text":"<pre><code>sync_account_locks()\n</code></pre> <p>Synchronize user account locks with their current quota status. Lock users who are out of time and within monitoring hours, unlock those who have time or are outside monitoring hours.</p> <p>This should be called: - On daemon startup (to restore consistent state) - During quota reset - When curfew windows change</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.unlock_all_managed_users","title":"unlock_all_managed_users","text":"<pre><code>unlock_all_managed_users() -&gt; int\n</code></pre> <p>Emergency function to unlock all managed user accounts. Used for manual recovery by administrators.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of users successfully unlocked</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.unlock_user_account","title":"unlock_user_account","text":"<pre><code>unlock_user_account(username: str) -&gt; bool\n</code></pre> <p>Unlock a previously locked user account. Uses usermod -U to re-enable password authentication.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if successful, False otherwise</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.unlock_user_account(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>The username to unlock</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.update_policy","title":"update_policy","text":"<pre><code>update_policy(policy: Policy)\n</code></pre> <p>Update the policy instance and re-evaluate rules.</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.user_exists","title":"user_exists","text":"<pre><code>user_exists(username)\n</code></pre> <p>Check if a user exists on the system.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>          \u2013            <p>True if user exists, False otherwise</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.user_exists(username)","title":"<code>username</code>","text":"\u2013            <p>The username to check</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.validate_username","title":"validate_username  <code>staticmethod</code>","text":"<pre><code>validate_username(username: str) -&gt; bool\n</code></pre> <p>Validate username format to prevent path traversal and injection attacks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if username is valid, False otherwise</p> </li> </ul>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.validate_username(username)","title":"<code>username</code>","text":"(<code>str</code>)           \u2013            <p>The username to validate</p>"},{"location":"reference/daemon/#guardian_daemon.user_manager.UserManager.write_time_rules","title":"write_time_rules","text":"<pre><code>write_time_rules()\n</code></pre> <p>Updates the time rules for all children according to the policy in /etc/security/time.conf, without overwriting foreign rules.</p> <p>This method: 1. First checks if the file is excessively large and needs cleanup 2. Compares existing content with what we need to write 3. Only writes if content needs updating</p>"},{"location":"reference/hub/","title":"Guardian Hub","text":""},{"location":"reference/hub/#guardian_hub","title":"guardian_hub","text":"<p>Modules:</p> <ul> <li> <code>api</code>           \u2013            <p>API-Endpunkte f\u00fcr guardian-hub (FastAPI).</p> </li> <li> <code>db</code>           \u2013            <p>Datenbankverbindung und Logik f\u00fcr guardian-hub.</p> </li> <li> <code>main</code>           \u2013            <p>Entry point for guardian-hub.</p> </li> <li> <code>models</code>           \u2013            <p>Datenbankmodelle f\u00fcr guardian-hub.</p> </li> </ul>"},{"location":"reference/hub/#guardian_hub.api","title":"api","text":"<p>API-Endpunkte f\u00fcr guardian-hub (FastAPI).</p> <p>NOTE: This module is not yet implemented. Only stub placeholder exists. The guardian-hub component is planned for Phase 1 of the project roadmap.</p> <p>Planned functionality: - REST API for policy management - User/device enrollment endpoints - Usage data synchronization - Real-time WebSocket connections</p>"},{"location":"reference/hub/#guardian_hub.db","title":"db","text":"<p>Datenbankverbindung und Logik f\u00fcr guardian-hub.</p> <p>NOTE: This module is not yet implemented. Only stub placeholder exists. The guardian-hub component is planned for Phase 1 of the project roadmap.</p> <p>Planned functionality: - PostgreSQL/SQLite database connection - Session management - User and device data persistence - Migration support via Alembic</p>"},{"location":"reference/hub/#guardian_hub.main","title":"main","text":"<p>Entry point for guardian-hub.</p> <p>NOTE: The guardian-hub is not yet implemented. Only stub placeholder exists. This is planned for Phase 1 of the project roadmap.</p> <p>When implemented, guardian-hub will provide: - Central policy management server - Multi-device coordination - Parent dashboard (web UI) - Real-time usage monitoring - Device enrollment and authentication</p> <p>Functions:</p> <ul> <li> <code>main</code>             \u2013              <p>Entry point for guardian-hub (NOT YET IMPLEMENTED).</p> </li> </ul>"},{"location":"reference/hub/#guardian_hub.main.main","title":"main","text":"<pre><code>main()\n</code></pre> <p>Entry point for guardian-hub (NOT YET IMPLEMENTED).</p> <p>This is a placeholder stub. When implemented, this will: - Start the FastAPI server - Initialize the database connection - Set up WebSocket handlers - Launch the parent dashboard UI</p>"},{"location":"reference/hub/#guardian_hub.models","title":"models","text":"<p>Datenbankmodelle f\u00fcr guardian-hub.</p> <p>NOTE: This module is not yet implemented. Only stub placeholder exists. The guardian-hub component is planned for Phase 1 of the project roadmap.</p> <p>Planned models: - User (children and parents) - Device (enrolled computers) - Policy (time quotas and curfews) - Session (active and historical sessions) - UsageData (cross-device usage tracking)</p>"}]}